<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 陈斌彬的技术博客]]></title>
  <link href="http://cnbin.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://cnbin.github.io/"/>
  <updated>2016-08-11T11:53:20+08:00</updated>
  <id>http://cnbin.github.io/</id>
  <author>
    <name><![CDATA[陈斌彬]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 标准库-1]]></title>
    <link href="http://cnbin.github.io/blog/2015/07/01/python-biao-zhun-ku-1/"/>
    <updated>2015-07-01T16:22:20+08:00</updated>
    <id>http://cnbin.github.io/blog/2015/07/01/python-biao-zhun-ku-1</id>
    <content type="html"><![CDATA[<!--More-->


<h2>一、正则表达式 (re包)</h2>

<p>正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。</p>

<p>正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找到的内容。</p>

<h3>1、语法</h3>

<p>有些时候，我们只是模糊地知道我们想要找什么，而不能具体说出我是在找“you”，比如说，我想找出字符串中包含的数字，这些数字可以是0到9中的任何一个。这些模糊的目标可以作为信息写入正则表达式，传递给 Python，从而让 Python 知道我们想要找的是什么。</p>

<p><a href="https://docs.python.org/2/library/re.html">官方documentation</a></p>

<p>在 Python 中使用正则表达式需要标准库中的一个包 re。</p>

<pre><code>import re
m = re.search('[0-9]','abcd4ef')
print(m.group(0))
</code></pre>

<p>re.search() 接收两个参数，第一个<code>'[0-9]'</code>就是我们所说的正则表达式，它告诉 Python 的 是：“听着，我从字符串想要找的是从0到9的一个数字字符”。</p>

<p>re.search() 如果从第二个参数找到符合要求的子字符串，就返回一个对象m，你可以通过 <code>m.group()</code> 的方法查看搜索到的结果。如果没有找到符合要求的字符，</p>

<p>re.search() 会返回 None。</p>

<p>如果你熟悉 Linux 或者 Perl, 你应该已经熟悉正则表达式。当我们打开 Linux shell 的时候，可以用正则表达式去查找或着删除我们想要的文件，比如说：</p>

<pre><code>$rm book[0-9][0-9].txt
</code></pre>

<p>这就是要删除类似于 book02.txt 的文件。book[0-9][0-9].txt 所包含的信息是，以 book 开头，后面跟两个数字字符，之后跟有<code>".txt"</code> 的文件名。如果不符合条件的文件名，比如说:</p>

<pre><code>bo12.txt
book1.txt
book99.text
</code></pre>

<p>都不会被选中。</p>

<p>Perl 中内建有正则表达式的功能，据说是所有正则表达式系统中最强的，这也是 Perl 成为系统管理员利器的一个原因。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etl1clsi3gj20dk03z3z3.jpg" alt="img" /></p>

<h3>2、正则表达式的函数</h3>

<pre><code>m = re.search(pattern, string)  # 搜索整个字符串，直到发现符合的子字符串。
m = re.match(pattern, string)   # 从头开始检查字符串是否符合正则表达式。必须从字符串的第一个字符开始就相符。
</code></pre>

<p>可以从这两个函数中选择一个进行搜索。上面的例子中，我们如果使用 <code>re.match()</code> 的话，则会得到 None，因为字符串的起始为‘a’， 不符合<code>'[0-9]'</code>的要求。</p>

<p>对于返回的 m, 我们使用 <code>m.group()</code> 来调用结果。（我们会在后面更详细解释 <code>m.group()</code> ）</p>

<p>我们还可以在搜索之后将搜索到的子字符串进行替换：</p>

<pre><code>str = re.sub(pattern, replacement, string) 
# 在string中利用正则变换pattern进行搜索，对于搜索到的字符串，用另一字符串replacement替换。返回替换后的字符串。
</code></pre>

<p>此外，常用的正则表达式函数还有：</p>

<pre><code>re.split()    # 根据正则表达式分割字符串， 将分割后的所有子字符串放在一个表(list)中返回
re.findall()  # 根据正则表达式搜索字符串，将所有符合的子字符串放在一给表(list)中返回
</code></pre>

<p>(在熟悉了上面的函数后，可以看一下 re.compile()，以便于提高搜索效率。)</p>

<h3>3、写一个正则表达式</h3>

<p>关键在于将信息写成一个正则表达式。我们先看正则表达式的常用语法：</p>

<h4>(1)、单个字符:</h4>

<pre><code>.          任意的一个字符
a|b        字符a或字符b
[afg]      a或者f或者g的一个字符        
[0-4]      0-4范围内的一个字符
[a-f]      a-f范围内的一个字符
[^m]       不是m的一个字符
\s         一个空格
\S         一个非空格
\d         [0-9]
\D         [^0-9]
\w         [0-9a-zA-Z]
\W         [^0-9a-zA-Z]
</code></pre>

<h4>(2)、重复</h4>

<p>紧跟在单个字符之后，表示多个这样类似的字符：</p>

<pre><code>*         重复 &gt;=0 次
+         重复 &gt;=1 次
?         重复 0或者1 次
{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]
{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。


正则表达        相符的字符串举例
[0-9]{3,5}     9678
a?b            b
a+b            aaaaab
</code></pre>

<h4>(3)、位置</h4>

<p>1.^ 字符串的起始位置</p>

<p>2.$ 字符串的结尾位置</p>

<pre><code>正则表达        相符的字符串举例       不相符字符串
^ab.*c$        abeec               cabeec (如果用re.search(), 将无法找到。)
</code></pre>

<h4>(4)、返回控制</h4>

<p>我们有可能对搜索的结果进行进一步精简信息。比如下面一个正则表达式：</p>

<pre><code>output_(\d{4})
</code></pre>

<p>该正则表达式用括号 <code>()</code> 包围了一个小的正则表达式，<code>\d{4}</code>。 这个小的正则表达式被用于从结果中筛选想要的信息（在这里是四位数字）。这样被括号圈起来的正则表达式的一部分，称为群(group)。</p>

<p>我们可以 <code>m.group(number)</code> 的方法来查询群。<code>group(0)</code> 是整个正则表达的搜索结果，<code>group(1)</code> 是第一个群……</p>

<pre><code>import re
m = re.search("output_(\d{4})", "output_1986.txt")
print(m.group(1))
</code></pre>

<p>我们还可以将群命名，以便更好地使用 <code>m.group</code> 查询:</p>

<pre><code>import re
m = re.search("output_(?P&lt;year&gt;\d{4})", "output_1986.txt")   #(?P&lt;name&gt;...) 为group命名
print(m.group("year"))
</code></pre>

<h2>二、时间与日期 (time, datetime包)</h2>

<p>Python 具有良好的时间和日期管理功能。实际上，计算机只会维护一个挂钟时间(wall clock time)，这个时间是从某个固定时间起点到现在的时间间隔。时间起点的选择与计算机相关，但一台计算机的话，这一时间起点是固定的。其它的日期信息都是从这一时间计算得到的。此外，计算机还可以测量 CPU 实际上运行的时间，也就是处理器时间(processor clock time)，以测量计算机性能。当 CPU 处于闲置状态时，处理器时间会暂停。</p>

<h3>1、time包</h3>

<p>time 包基于 C 语言的库函数(library functions)。Python 的解释器通常是用 C 编写的，Python 的一些函数也会直接调用 C 语言的库函数。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etl256k2f0j20cy01edfw.jpg" alt="img" /></p>

<p>time.sleep() 可以将程序置于休眠状态，直到某时间间隔之后再唤醒程序，让程序继续运行。</p>

<pre><code>import time
print('start')
time.sleep(10)     # sleep for 10 seconds
print('wake up')
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etl28ct09fj20as01dmx6.jpg" alt="img" /></p>

<p>当我们需要定时地查看程序运行状态时，就可以利用该方法。</p>

<p>time 包还定义了 <code>struct_time</code> 对象。该对象实际上是将挂钟时间转换为年、月、日、时、分、秒……等日期信息，存储在该对象的各个属性中(tm_year, tm_mon, tm_mday&hellip;)。下面方法可以将挂钟时间转换为 <code>struct_time</code> 对象:</p>

<pre><code>st = time.gmtime()      # 返回struct_time格式的UTC时间
st = time.localtime()   # 返回struct_time格式的当地时间, 当地时区根据系统环境决定。

s  = time.mktime(st)    # 将struct_time格式转换成wall clock time
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etl2cdnr1bj20ad00y0sq.jpg" alt="img" /></p>

<h3>2、datetime包</h3>

<h4>(1)、简介</h4>

<p>datetime 包是基于time包的一个高级包， 为我们提供了多一层的便利。</p>

<p>datetime 可以理解为date和time两个组成部分。date是指年月日构成的日期(相当于日历)，time 是指时分秒微秒构成的一天24小时中的具体时间(相当于手表)。你可以将这两个分开管理(<code>datetime.date</code> 类，<code>datetime.time</code> 类)，也可以将两者合在一起(datetime.datetime类)。由于其构造大同小异，我们将只介绍
<code>datetime.datetime</code> 类。</p>

<p>比如说我现在看到的时间，是2015年6月29日10时3分，我们可以用如下方式表达：</p>

<pre><code>import datetime
t = datetime.datetime(2015,6,29,10,3)
print(t)
</code></pre>

<p>所返回的 t 有如下属性:</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etl2f8z3xej20bh00xgln.jpg" alt="img" /></p>

<h4>(2)、运算</h4>

<p>datetime 包还定义了时间间隔对象(timedelta)。一个时间点(datetime)加上一个时间间隔(timedelta)可以得到一个新的时间点(datetime)。比如今天的上午3点加上5个小时得到今天的上午8点。同理，两个时间点相减会得到一个时间间隔。</p>

<pre><code>import datetime
t      = datetime.datetime(2015,6,3,21,30)
t_next = datetime.datetime(2015,6,5,23,30)
delta1 = datetime.timedelta(seconds = 600)
delta2 = datetime.timedelta(weeks = 3)
print(t + delta1)
print(t + delta2)
print(t_next - t)
</code></pre>

<p>在给 <code>datetime.timedelta</code> 传递参数（如上的 seconds 和 weeks）的时候，还可以是 days, hours, milliseconds, microseconds。</p>

<p>两个 datetime 对象还可以进行比较。比如使用上面的 t 和 t_next:</p>

<pre><code>print(t &gt; t_next)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pyhton 基础-2]]></title>
    <link href="http://cnbin.github.io/blog/2015/07/01/pyhton-ji-chu-2/"/>
    <updated>2015-07-01T15:03:30+08:00</updated>
    <id>http://cnbin.github.io/blog/2015/07/01/pyhton-ji-chu-2</id>
    <content type="html"><![CDATA[<!--More-->


<h2>一、循环</h2>

<h3>1、for循环</h3>

<p>for 循环需要预先设定好循环的次数(n)，然后执行隶属于 for 的语句n次。</p>

<p>基本构造是：</p>

<pre><code>for 元素 in 序列: 
    statement
</code></pre>

<p>举例来说，我们编辑一个叫 forDemo.py 的文件：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etkz2l4oomj208y02o3yi.jpg" alt="img" /></p>

<p>这个循环就是每次从表 [3,4.4,&lsquo;life&rsquo;] 中取出一个元素（回忆：表是一种序列），然后将这个元素赋值给a，之后执行隶属于 for 的操作(print)。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etkz2kjn41j20bk02aweg.jpg" alt="img" /></p>

<p>介绍一个新的 Python 函数 range()，来帮助你建立表。</p>

<pre><code>idx = range(5)
print idx
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etkz76r93fj209t00wweg.jpg" alt="img" /></p>

<p>可以看到 idx 是[0,1,2,3,4]</p>

<p>这个函数的功能是新建一个表。这个表的元素都是整数，从0开始，下一个元素比前一个大1， 直到函数中所写的上限 （不包括该上限本身）。</p>

<h3>2、while循环</h3>

<p>while 的用法是：</p>

<pre><code>while 条件:
    statement
</code></pre>

<p>while 会不停地循环执行隶属于它的语句，直到条件为假(False)。</p>

<p>举例：</p>

<pre><code>while i &lt; 10:
    print i
    i = i + 1
</code></pre>

<h3>3、中断循环</h3>

<p>continue 在循环的某一次执行中，如果遇到 continue, 那么跳过这一次执行，进行下一次的操作</p>

<p>break 停止执行整个循环</p>

<pre><code>for i in range(10):
    if i == 2: 
        continue
    print i
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etkzci63utj20ce04n3yn.jpg" alt="img" /></p>

<p>当循环执行到 i = 2 的时候，if 条件成立，触发 continue, 跳过本次执行(不执行print)，继续进行下一次执行(i = 3)。</p>

<pre><code>for i in range(10):
    if i == 2:        
        break
    print i
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etkzefwh3wj20bf01d3yg.jpg" alt="img" /></p>

<p>当循环执行到 i = 2 的时候，if 条件成立，触发 break, 整个循环停止。</p>

<h2>二、函数</h2>

<p>函数最重要的目的是方便我们重复使用相同的一段程序。</p>

<p>将一些操作隶属于一个函数，以后你想实现相同的操作的时候，只用调用函数名就可以，而不需要重复敲所有的语句。</p>

<h3>1、函数的定义</h3>

<p>首先，我们要定义一个函数, 以说明这个函数的功能。</p>

<pre><code>def square_sum(a,b):
    c = a**2 + b**2
    return c
</code></pre>

<p>这个函数的功能是求两个数的平方和。</p>

<p>首先，def，这个关键字通知<code>python</code>：我在定义一个函数。square_sum 是函数名。</p>

<p>括号中的 a, b 是函数的参数，是对函数的输入。参数可以有多个，也可以完全没有（但括号要保留）。</p>

<p>我们已经在循环和选择中见过冒号和缩进来表示的隶属关系。</p>

<ul>
<li>c = a2 + b2 # 这一句是函数内部进行的运算</li>
<li>return c # 返回c的值，也就是输出的功能。Python 的函数允许不返回值，也就是不用 return。</li>
<li>return 可以返回多个值，以逗号分隔。相当于返回一个 tuple(定值表)。</li>
<li>return a,b,c # 相当于 return (a,b,c) 在 python 中#代表注释，编译器将跳过#后的内容。</li>
<li>在 Python 中，当程序执行到 return 的时候，程序将停止执行函数内余下的语句。return 并不是必须的，当没有 return, 或者 return 后面没有返回值时，函数将自动返回 None。None 是 Python 中的一个特别的数据类型，用来表示什么都没有，相当于 C 中的 NULL。None 多用于关键字参数传递的默认值。</li>
</ul>


<h3>2、函数调用和参数传递</h3>

<p>定义过函数后，就可以在后面程序中使用这一函数：</p>

<pre><code>print square_sum(3,4)
</code></pre>

<p>Python 通过位置，知道3对应的是函数定义中的第一个参数a， 4对应第二个参数b，然后把参数传递给函数 square_sum。</p>

<p>函数经过运算，返回值25, 这个25被 print 打印出来。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etkzlqoxiuj20c70383yl.jpg" alt="img" /></p>

<h2>三、面向对象的基本概念</h2>

<h3>1、相近对象，归为类</h3>

<p>在人类认知中，会根据属性相近把东西归类，并且给类别命名。比如说，鸟类的共同属性是有羽毛，通过产卵生育后代。任何一只特别的鸟都在鸟类的原型基础上的。</p>

<p>面向对象就是模拟了以上人类认知过程。在 Python 语言，为了听起来酷，我们把上面说的“东西”称为对象（object）。</p>

<p>先定义鸟类：</p>

<pre><code>class Bird(object):
    have_feather = True
    way_of_reproduction  = 'egg'
</code></pre>

<p>我们定义了一个类别（class），就是鸟（Bird）。在隶属于这个类比的语句块中，我们定义了两个变量，一个是有羽毛（have_feather），一个是生殖方式（way_of_reproduction）,这两个变量对应我们刚才说的属性（attribute）。我们暂时先不说明括号以及其中的内容，记为问题1。</p>

<p>假设我养了一只小鸡，叫 summer。它是个对象，且属于鸟类。使用前面定义的类：</p>

<pre><code>summer = Bird()
print summer.way_of_reproduction
</code></pre>

<p>通过第一句创建对象，并说明 summer 是类别鸟中的一个对象，summer 就有了鸟的类属性，对属性的引用是通过 <code>对象.属性（object.attribute）</code> 的形式实现的。</p>

<h3>2、动作</h3>

<p>日常认知中，我们在通过属性识别类别的时候，有时根据这个东西能做什么事情来区分类别。比如说，鸟会移动。这样，鸟就和房屋的类别区分开了。这些动作会带来一定的结果，比如移动导致位置的变化。</p>

<p>这样的一些“行为”属性为方法（method）。Python 中通过在类的内部定义函数，来说明方法。</p>

<pre><code>class Bird(object):
    have_feather = True
    way_of_reproduction = 'egg'
    def move(self, dx, dy):
        position = [0,0]
        position[0] = position[0] + dx
        position[1] = position[1] + dy
        return position

summer = Bird()
print 'after move:',summer.move(5,8)
</code></pre>

<h3>3、子类</h3>

<p>类别本身还可以进一步细分成子类。</p>

<p>比如说，鸟类可以进一步分成鸡，大雁，黄鹂。</p>

<p>在 OOP 中，我们通过继承(inheritance)来表达上述概念。</p>

<pre><code>class Chicken(Bird):
    way_of_move = 'walk'
    possible_in_KFC = True

class Oriole(Bird):
    way_of_move = 'fly'
    possible_in_KFC = False

summer = Chicken()
print summer.have_feather
print summer.move(5,8)
</code></pre>

<h2>四、面向对象的进一步拓展</h2>

<h3>1、调用类的其它信息</h3>

<pre><code>class Human(object):
    laugh = 'hahahaha'
    def show_laugh(self):
        print self.laugh
    def laugh_100th(self):
        for i in range(100):
            self.show_laugh()

li_lei = Human()          
li_lei.laugh_100th()
</code></pre>

<h3>2、<code>__init__()</code> 方法</h3>

<p><code>__init__()</code> 是一个特殊方法(special method)。Python 有一些特殊方法。Python 会特殊的对待它们。特殊方法的特点是名字前后有两个下划线。</p>

<p>如果你在类中定义了 <code>__init__()</code> 这个方法，创建对象时，Python 会自动调用这个方法。这个过程也叫初始化。</p>

<pre><code>class Bird(object):
    have_feather = True
    way_of_reproduction = 'egg'
    def move(self, dx, dy):
        position = [0,0]
        position[0] = position[0] + dx
        position[1] = position[1] + dy
        return position


class happyBird(Bird):
        def __init__(self,more_words):
            print 'We are happy birds.',more_words

summer = happyBird('Happy,Happy!')
</code></pre>

<p>这里继承了 Bird 类。屏幕上打印：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etl0kgwsw0j209m00ymx7.jpg" alt="img" /></p>

<p>我们看到，尽管我们只是创建了summer对象，但 <code>__init__()</code> 方法被自动调用了。最后一行的语句(summer = happyBird&hellip;)先创建了对象，然后执行：</p>

<pre><code>summer.__init__(more_words)
</code></pre>

<p>&lsquo;Happy,Happy!&rsquo; 被传递给了 <code>__init__()</code> 的参数 <code>more_words</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 基础-1]]></title>
    <link href="http://cnbin.github.io/blog/2015/06/25/python-ji-chu/"/>
    <updated>2015-06-25T16:51:37+08:00</updated>
    <id>http://cnbin.github.io/blog/2015/06/25/python-ji-chu</id>
    <content type="html"><![CDATA[<!--More-->


<h3>1、Python命令行</h3>

<p>在 Linux/Unix 命令行输入:</p>

<pre><code>$python
</code></pre>

<p>将直接进入 <code>python</code>。然后在命令行提示符 <code>&gt;&gt;&gt;</code> 后面输入:</p>

<pre><code>&gt;&gt;&gt;print('Hello World!')
</code></pre>

<p>可以看到，随后在屏幕上输出:</p>

<pre><code>Hello World!
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1ete4jyc7jtj20e203bdgp.jpg" alt="img" /></p>

<h3>2、写一段小程序</h3>

<p>另一个使用 Python 的方法，是写一个 Python 程序。用文本编辑器写一个 <code>.py</code> 结尾的文件，比如说 <code>hello.py</code></p>

<p>在 <code>hello.py</code> 中写入如下，并保存:</p>

<pre><code>print('Hello World!')
</code></pre>

<p>退出文本编辑器，然后在命令行输入:</p>

<pre><code>$python hello.py
</code></pre>

<p>来运行 <code>hello.py</code>。可以看到 <code>Python</code> 随后输出:</p>

<pre><code>Hello World!
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1ete4mnjbgej20bz02kq2y.jpg" alt="img" /></p>

<h3>3、脚本</h3>

<p>我们还可以把 Python 程序 <code>hello.py</code> 改成一个可执行的脚本，可以直接执行：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1ete4op56doj20c2021q31.jpg" alt="img" /></p>

<p>需要修改上面程序的权限为可执行：</p>

<pre><code>chmod 755 hello.py
</code></pre>

<p>然后再命令行中，输入：</p>

<pre><code>./hello.py
</code></pre>

<p>就可以直接运行了</p>

<h2>基本数据类型</h2>

<h3>1、变量不需要声明</h3>

<p>Python 的变量不需要声明，你可以直接输入：</p>

<pre><code>&gt;&gt;&gt;a = 10
</code></pre>

<p>那么你的内存里就有了一个变量 <code>a</code>， 它的值是10，它的类型是 <code>integer</code> (整数)。 在此之前你不需要做什么特别的声明，而数据类型是 <code>Python</code> 自动决定的。</p>

<pre><code>&gt;&gt;&gt;print a

&gt;&gt;&gt;print type(a)
</code></pre>

<p>那么会有如下输出：</p>

<pre><code>10
&lt;type 'int'&gt;
</code></pre>

<p>这里，我们学到一个内置函数 <code>type()</code>, 用以查询变量的类型。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1ete4rpkkaxj20ei05w0u3.jpg" alt="img" /></p>

<h3>2、回收变量名</h3>

<p>如果你想让 a 存储不同的数据，你不需要删除原有变量就可以直接赋值。</p>

<pre><code>&gt;&gt;&gt;a = 1.3

&gt;&gt;&gt;print a,type(a)
</code></pre>

<p>会有如下输出：</p>

<pre><code>1.3 &lt;type 'float'&gt;
</code></pre>

<p>我们看到 <code>print</code> 的另一个用法，也就是 <code>print</code> 后跟多个输出，以逗号分隔。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1ete4tg7nz7j20e807rmys.jpg" alt="img" /></p>

<h3>3、常用数据类型</h3>

<pre><code>变量  数据类型
a=10    int 整数
a=1.3   float 浮点数
a=True  真值(True/False)
a='Hello!'  字符串
</code></pre>

<p>以上是最常用的数据类型，对于字符串来说，也可以用双引号。</p>

<h2>序列</h2>

<p><code>sequence</code>(序列)是一组有顺序的元素的集合</p>

<p>(严格的说，是对象的集合，但鉴于我们还没有引入“对象”概念，暂时说元素)</p>

<p>序列可以包含一个或多个元素，也可以没有任何元素。</p>

<p>我们之前所说的基本数据类型，都可以作为序列的元素。元素还可以是另一个序列，以及我们以后要介绍的其他对象。</p>

<p>序列有两种：<code>tuple</code>（定值表； 也有翻译为元组） 和 <code>list</code> (表)</p>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1ete4wgt0e4j20ao03qaao.jpg" alt="img" /></p>

<p>tuple 和 list 的主要区别在于，一旦建立，<code>tuple</code> 的各个元素不可再变更，而 <code>list</code> 的各个元素可以再变更。</p>

<p>一个序列作为另一个序列的元素：</p>

<pre><code>&gt;&gt;&gt;s3 = [1,[3,4,5]]
</code></pre>

<p>空序列：</p>

<pre><code>&gt;&gt;&gt;s4 = []
</code></pre>

<h3>1、元素的引用</h3>

<p>序列元素的下标从0开始：</p>

<pre><code>&gt;&gt;&gt;print s1[0]

&gt;&gt;&gt;print s2[2]

&gt;&gt;&gt;print s3[1][2]
</code></pre>

<p>由于 list 的元素可变更，你可以对 list 的某个元素赋值：</p>

<pre><code>&gt;&gt;&gt;s2[1] = 3.0

&gt;&gt;&gt;print s2
</code></pre>

<p>如果你对 tuple 做这样的操作，会得到错误提示。</p>

<p>所以，可以看到，序列的引用通过 <code>s[int]</code> 实现，(int 为下标)。</p>

<h3>2、其他引用方式</h3>

<p>范围引用： 基本样式 [下限:上限:步长]</p>

<pre><code>&gt;&gt;&gt;print s1[:5]             # 从开始到下标4 （下标5的元素 不包括在内）

&gt;&gt;&gt;print s1[2:]             # 从下标2到最后

&gt;&gt;&gt;print s1[0:5:2]          # 从下标0到下标4 (下标5不包括在内)，每隔2取一个元素 （下标为0，2，4的元素）

&gt;&gt;&gt;print s1[2:0:-1]         # 从下标2到下标1
</code></pre>

<p>从上面可以看到，在范围引用的时候，如果写明上限，那么这个上限本身不包括在内。</p>

<p>尾部元素引用：</p>

<pre><code>&gt;&gt;&gt;print s1[-1]             # 序列最后一个元素

&gt;&gt;&gt;print s1[-3]             # 序列倒数第三个元素
</code></pre>

<p>同样，如果 <code>s1[0:-1]</code>, 那么最后一个元素不会被引用 （再一次，不包括上限元素本身）。</p>

<h3>3、字符串是元组</h3>

<p>字符串是一种特殊的元素，因此可以执行元组的相关操作。</p>

<pre><code>&gt;&gt;&gt;str = 'abcdef'

&gt;&gt;&gt;print str[2:4]
</code></pre>

<h2>运算</h2>

<h3>1、数学运算</h3>

<pre><code>&gt;&gt;&gt;print 1+9        # 加法

&gt;&gt;&gt;print 1.3-4      # 减法

&gt;&gt;&gt;print 3*5        # 乘法

&gt;&gt;&gt;print 4.5/1.5    # 除法

&gt;&gt;&gt;print 3**2       # 乘方     

&gt;&gt;&gt;print 10%3       # 求余数
</code></pre>

<h3>2、判断</h3>

<p>判断是真还是假，返回 <code>True/False</code>:</p>

<pre><code>&gt;&gt;&gt;print 5==6               # =， 相等

&gt;&gt;&gt;print 8.0!=8.0           # !=, 不等

&gt;&gt;&gt;print 3&lt;3, 3&lt;=3          # &lt;, 小于; &lt;=, 小于等于

&gt;&gt;&gt;print 4&gt;5, 4&gt;=0          # &gt;, 大于; &gt;=, 大于等于

&gt;&gt;&gt;print 5 in [1,3,5]       # 5是list [1,3,5]的一个元素
</code></pre>

<h3>3、逻辑运算</h3>

<p>True/False 之间的运算：</p>

<pre><code>&gt;&gt;&gt;print True and True, True and False      # and, “与”运算， 两者都为真才是真

&gt;&gt;&gt;print True or False                      # or, "或"运算， 其中之一为真即为真

&gt;&gt;&gt;print not True                           # not, “非”运算， 取反
</code></pre>

<h2>缩进和选择</h2>

<h3>1、缩进</h3>

<p>Python 最具特色的是用缩进来标明成块的代码。我下面以if选择结构来举例。if 后面跟随条件，如果条件成立，则执行归属于 if 的一个代码块。</p>

<p>先看 C 语言的表达方式（注意，这是 C，不是 Python!）</p>

<pre><code>if ( i &gt; 0 )
{
    x = 1;
    y = 2;
}
</code></pre>

<p>如果 <code>i &gt; 0</code> 的话，我们将进行括号中所包括的两个赋值操作。括号中包含的就是块操作，它隶属于 if。</p>

<p>在 Python 中，同样的目的，这段话是这样的：</p>

<pre><code>if i &gt; 0:
    x = 1
    y = 2
</code></pre>

<p>在 Python 中， 去掉了 <code>i &gt; 0</code> 周围的括号，去除了每个语句句尾的分号，表示块的花括号也消失了。</p>

<p>多出来了 <code>if ...</code> 之后的 <code>:(冒号)</code>, 还有就是 <code>x = 1</code> 和 <code>y =2</code> 前面有四个空格的缩进。通过缩进，Python 识别出这两个语句是隶属于 <code>if</code>。</p>

<p>Python 这样设计的理由纯粹是为了程序好看。</p>

<h3>2、if语句</h3>

<p>写一个完整的程序，命名为 <code>ifDemo.py</code>。这个程序用于实现 if 结构。</p>

<pre><code>i = 1
x = 1
if i &gt; 0:
    x = x+1
print x
</code></pre>

<p>用 <code>cd</code> 命令进入该文件所在目录，然后输入命令运行它：</p>

<pre><code>$python ifDemo.py  # 运行
</code></pre>

<p>程序运行到 if 的时候，条件为 True，因此执行 <code>x = x+1</code>。</p>

<pre><code> ~/ [master*] python ifDemo.py
2
</code></pre>

<p>print x 语句没有缩进，那么就是 if 之外。</p>

<p>如果将第一句改成 <code>i = -1</code>，那么 if 遇到假值 (False), <code>x = x+1</code> 隶属于 if , 这一句跳过。<code>print x</code> 没有缩进，是 if 之外，不跳过，继续执行。</p>

<p>这种以四个空格的缩进来表示隶属关系的书写方式，以后还会看到。强制缩进增强了程序的可读性。</p>

<p>复杂一些的 if 选择：</p>

<pre><code>i = 1

if i &gt; 0:
    print 'positive i'
    i = i + 1
elif i == 0:
    print 'i is 0'
    i = i * 10
else:
    print 'negative i'
    i = i - 1

print 'new i:',i
</code></pre>

<p>这里有三个块，分别属于 <code>if，elif，else</code> 引领。</p>

<p>Python 检测条件，如果发现 if 的条件为假，那么跳过后面紧跟的块，检测下一个 elif 的条件； 如果还是假，那么执行 else 块。</p>

<p>通过上面的结构将程序分出三个分支。程序根据条件，只执行三个分支中的一个。</p>

<p>整个 if 可以放在另一个 if 语句中，也就是 if 结构的嵌套使用：</p>

<pre><code>i  = 5
if i &gt; 1:
    print 'i bigger than 1'
    print 'good'
    if i &gt; 2:
        print 'i bigger than 2'
        print 'even better'
</code></pre>

<p>if i > 2 后面的块相对于该 if 缩进了四个空格，以表明其隶属于该 if ，而不是外层的 if 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 进阶-2]]></title>
    <link href="http://cnbin.github.io/blog/2015/06/25/python-ji-jie-2/"/>
    <updated>2015-06-25T09:45:30+08:00</updated>
    <id>http://cnbin.github.io/blog/2015/06/25/python-ji-jie-2</id>
    <content type="html"><![CDATA[<!--More-->


<h2>一、循环设计</h2>

<h3>1、range()</h3>

<p>在 Python 中，for 循环后的 <code>in</code> 跟随一个序列的话，循环每次使用的序列元素，而不是序列的下标。</p>

<p>之前我们已经使用过 range() 来控制 for 循环。现在，我们继续开发 range 的功能，以实现下标对循环的控制：</p>

<pre><code># range.py
S = 'abcdefghijk'
for i in range(0,len(S),2):
    print S[i]
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf085tpvkj208t038t8o.jpg" alt="img" /></p>

<p>在该例子中，我们利用 <code>len()</code> 函数和 <code>range()</code> 函数，用 <code>i</code> 作为  <code>S</code> 序列的下标来控制循环。在 <code>range</code> 函数中，分别定义上限，下限和每次循环的步长。这就和 C 语言中的 <code>for</code> 循环相类似了。</p>

<h3>2、enumerate()</h3>

<p>利用 <code>enumerate()</code> 函数，可以在每次循环中同时得到下标和元素：</p>

<pre><code>S = 'abcdefghijk'
for (index,char) in enumerate(S):
    print index
    print char
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf0bmg6krj208l0auaaa.jpg" alt="img" /></p>

<p>实际上，<code>enumerate()</code> 在每次循环中，返回的是一个包含两个元素的定值表(tuple)，两个元素分别赋予 <code>index</code> 和char。</p>

<h3>3、zip()</h3>

<p>如果你多个等长的序列，然后想要每次循环时从各个序列分别取出一个元素，可以利用 zip() 方便地实现：</p>

<pre><code>ta = [1,2,3]
tb = [9,8,7]
tc = ['a','b','c']
for (a,b,c) in zip(ta,tb,tc):
    print(a,b,c)
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf0dx6x26j207p01uglo.jpg" alt="img" /></p>

<p>每次循环时，从各个序列分别从左到右取出一个元素，合并成一个 tuple，然后 tuple 的元素赋予给 a,b,c 。</p>

<p>zip( ) 函数的功能，就是从多个列表中，依次各取出一个元素。每次取出的(来自不同列表的)元素合成一个元组，合并成的元组放入 <code>zip()</code> 返回的列表中。</p>

<p>zip( ) 函数起到了聚合列表的功能。</p>

<p>我们可以分解聚合后的列表，如下:</p>

<pre><code>ta = [1,2,3]
tb = [9,8,7

# cluster
zipped = zip(ta,tb)
print(zipped)

# decompose
na, nb = zip(*zipped)
print(na, nb)
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etf0g3pkmbj207q01hwel.jpg" alt="img" /></p>

<h2>二、循环对象</h2>

<h3>1、什么是循环对象</h3>

<p>循环对象是这样一个对象，它包含有一个 <code>next()</code> 方法 ( <code>__next__()</code> 方法，在<code>python 3x</code> 中 )， 这个方法的目的是进行到下一个结果，而在结束一系列结果之后，举出 StopIteration 错误。</p>

<p>当一个循环结构（比如 for ）调用循环对象时，它就会每次循环的时候调用 <code>next()</code> 方法，直到 StopIteration 出现，for 循环接收到，就知道循环已经结束，停止调用 <code>next()</code>。</p>

<p>假设我们有一个 <code>test.txt</code> 的文件:</p>

<pre><code>1234
abcd
efg
</code></pre>

<p>我们运行一下 python 命令行：</p>

<pre><code>&gt;&gt;&gt;f = open('test.txt')

&gt;&gt;&gt;f.next()

&gt;&gt;&gt;f.next()

...
</code></pre>

<p>不断输入 <code>f.next()</code>，直到最后出现 StopIteration 。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etf0k3wnd5j208l05374y.jpg" alt="img" /></p>

<p>open() 返回的实际上是一个循环对象，包含有 <code>next()</code> 方法。而该 <code>next()</code> 方法每次返回的就是新的一行的内容，到达文件结尾时举出 StopIteration。这样，我们相当于手工进行了循环。</p>

<p>自动进行的话，就是：</p>

<pre><code>for line in open('test.txt'):
    print line
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf0mrcvkhj20ao03b3yi.jpg" alt="img" />
在这里，for 结构自动调用 next() 方法，将该方法的返回值赋予给 line。循环知道出现 StopIteration 的时候结束。</p>

<p>相对于序列，用循环对象的好处在于：不用在循环还没有开始的时候，就生成好要使用的元素。所使用的元素可以在循环过程中逐次生成。这样，节省了空间，提高了效率，编程更灵活。</p>

<h3>2、迭代器</h3>

<p>从技术上来说，循环对象和 for 循环调用之间还有一个中间层，就是要将循环对象转换成迭代器(iterator)。这一转换是通过使用 iter() 函数实现的。但从逻辑层面上，常常可以忽略这一层，所以循环对象和迭代器常常相互指代对方。</p>

<h3>3、生成器</h3>

<p>生成器(generator)的主要目的是构成一个用户自定义的循环对象。</p>

<p>生成器的编写方法和函数定义类似，只是在 return 的地方改为 <code>yield</code>。生成器中可以有多个 <code>yield</code>。当生成器遇到一个 <code>yield</code> 时，会暂停运行生成器，返回 <code>yield</code> 后面的值。当再次调用生成器的时候，会从刚才暂停的地方继续运行，直到下一个 <code>yield</code> 。生成器自身又构成一个循环器，每次循环使用一个 <code>yield</code> 返回的值。</p>

<p>下面是一个生成器:</p>

<pre><code>def gen():
    a = 100
    yield a
    a = a*8
    yield a
    yield 1000
</code></pre>

<p>该生成器共有三个 yield， 如果用作循环器时，会进行三次循环。</p>

<pre><code>for i in gen():
    print i
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etf0qsbwfzj206205hjro.jpg" alt="img" /></p>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etf0qrrp9cj208g01v3yi.jpg" alt="img" /></p>

<p>再考虑如下一个生成器:</p>

<pre><code>def gen():
    for i in range(4):
        yield i
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf0uf6br3j207h047aa9.jpg" alt="img" /></p>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etf0ufxo7cj209k02a749.jpg" alt="img" /></p>

<p>它又可以写成生成器表达式(Generator Expression)：</p>

<pre><code>G = (x for x in range(4))
</code></pre>

<p>生成器表达式是生成器的一种简便的编写方式。</p>

<h3>4、表推导</h3>

<p>表推导(list comprehension)是快速生成表的方法。它的语法简单，很有实用价值。</p>

<p>假设我们生成表 L ：</p>

<pre><code>L = [ ]
for x in range(10):
    L.append(x**2)
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf14tlrskj206x03wjri.jpg" alt="img" /></p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf13ig40rj207z058jrg.jpg" alt="img" /></p>

<p>以上产生了表 L，但实际上有快捷的写法，也就是表推导的方式:</p>

<pre><code>L = [x**2 for x in range(10)]
</code></pre>

<p>这与生成器表达式类似，只不过用的是中括号。</p>

<h2>三、函数对象</h2>

<p>秉承着一切皆对象的理念，我们再次回头来看函数(function)。函数也是一个对象，具有属性。作为对象，它还可以赋值给其它对象名，或者作为参数传递。</p>

<h3>1、lambda 函数</h3>

<p>在展开之前，我们先提一下 lambda 函数。可以利用 lambda 函数的语法，定义函数。lambda 例子如下：</p>

<pre><code>func = lambda x,y: x + y
print func(3,4)
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etf0xacsxej208600zjrb.jpg" alt="img" />
lambda 生成一个函数对象。该函数参数为 x,y，返回值为 x+y。函数对象赋给 func。func 的调用与正常函数无异。</p>

<p>以上定义可以写成以下形式：</p>

<pre><code>def func(x, y):
    return x + y
</code></pre>

<h3>2、函数作为参数传递</h3>

<p>函数可以作为一个对象，进行参数传递。函数名(比如 func )即该对象。比如说:</p>

<pre><code>def test(f, a, b):
    print 'test'
    print f(a, b)

test(func, 3, 5)
</code></pre>

<p>test 函数的第一个参数f就是一个函数对象。将 func 传递给 f，test 中的 <code>f()</code> 就拥有了 <code>func()</code> 的功能。</p>

<p>我们因此可以提高程序的灵活性。可以使用上面的test函数，带入不同的函数参数。比如:</p>

<pre><code>test((lambda x,y: x**2 + y), 6, 9)
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etf1c4ypzsj20aa045mxg.jpg" alt="img" /></p>

<h3>3、map( )函数</h3>

<p>map( ) 是 Python 的内置函数。它的第一个参数是一个函数对象。</p>

<pre><code>re = map((lambda x: x+3),[1,3,5,6])
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf1fmz056j20at028wek.jpg" alt="img" /></p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf1fnaxukj207x00zaa0.jpg" alt="img" /></p>

<p>这里，map( ) 有两个参数，一个是 lambda 所定义的函数对象，一个是包含有多个元素的表。map( ) 的功能是将函数对象依次作用于表的每一个元素，每次作用的结果储存于返回的表 re 中。map 通过读入的函数(这里是 lambda 函数)来操作数据（这里“数据”是表中的每一个元素，“操作”是对每个数据加3）。</p>

<p>在 Python 3.X 中，map() 的返回值是一个循环对象。可以利用 list() 函数，将该循环对象转换成表。</p>

<p>如果作为参数的函数对象有多个参数，可使用下面的方式，向 map() 传递函数参数的多个参数：</p>

<pre><code>re = map((lambda x,y: x+y),[1,2,3],[6,7,9])
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf1i4ygxij20cq03pt98.jpg" alt="img" /></p>

<p>map( ) 将每次从两个表中分别取出一个元素，带入 lambda 所定义的函数。</p>

<h3>4、filter( )函数</h3>

<p>filter 函数的第一个参数也是一个函数对象。它也是将作为参数的函数对象作用于多个元素。如果函数对象返回的是 True，则该次的元素被储存于返回的表中。 filter 通过读入的函数来筛选数据。同样，在 Python 3.X 中，filter 返回的不是表，而是循环对象。</p>

<p>filter 函数的使用如下例:</p>

<pre><code>def func(a):
    if a &gt; 100:
        return True
    else:
        return False

print filter(func,[10,56,101,500])
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf1i4ygxij20cq03pt98.jpg" alt="img" /></p>

<h3>5、reduce( ) 函数</h3>

<p>reduce 函数的第一个参数也是函数，但有一个要求，就是这个函数自身能接收两个参数。reduce 可以累进地将函数作用于各个参数。如下例：</p>

<pre><code>print reduce((lambda x,y: x+y),[1,2,5,7,9])
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf1nk7e85j20cl048wf2.jpg" alt="img" /></p>

<p>reduce 的第一个参数是 lambda 函数，它接收两个参数 x,y, 返回 x+y。</p>

<p>reduce 将表中的前两个元素(1和2)传递给 lambda 函数，得到3。该返回值(3)将作为 lambda 函数的第一个参数，而表中的下一个元素(5)作为 lambda 函数的第二个参数，进行下一次的对 lambda 函数的调用，得到8。依次调用 lambda 函数，每次 lambda 函数的第一个参数是上一次运算结果，而第二个参数为表中的下一个元素，直到表中没有剩余元素。</p>

<p>上面例子，相当于<code>(((1+2)+5)+7)+9</code></p>

<p>提醒： <code>reduce()</code> 函数在3.0里面不能直接用的，它被定义在了 functools 包里面，需要引入包。</p>

<h2>四、错误处理</h2>

<h3>1、异常处理</h3>

<p>在项目开发中，异常处理是不可或缺的。异常处理帮助人们 debug，通过更加丰富的信息，让人们更容易找到 bug 的所在。异常处理还可以提高程序的容错性。</p>

<p>我们之前在讲循环对象的时候，曾提到一个 StopIteration 的异常，该异常是在循环对象穷尽所有元素时的报错。</p>

<p>我们以它为例，来说明基本的异常处理。</p>

<p>一个包含异常的程序:</p>

<pre><code>re = iter(range(5))
for i in range(100):
    print re.next()
print 'HaHaHaHa'
</code></pre>

<p>首先，我们定义了一个循环对象 re，该循环对象将进行5次循环，每次使用序列的一个元素。</p>

<p>在随后的 for 循环中，我们手工调用 next( ) 函数。当循环进行到第6次的时候，<code>re.next()</code> 不会再返回元素，而是抛出 <code>(raise)StopIteration</code> 的异常。整个程序将会中断。</p>

<p>我们可以修改以上异常程序，直到完美的没有 bug。但另一方面，如果我们在写程序的时候，知道这里可能犯错以及可能的犯错类型，我们可以针对该异常类型定义好”应急预案“。</p>

<pre><code>re = iter(range(5))
try:
    for i in range(100):
        print re.next()
except StopIteration:
    print 'here is end ',i

print 'HaHaHaHa'
</code></pre>

<p>在 try 程序段中，我们放入容易犯错的部分。我们可以跟上 except，来说明如果在 try 部分的语句发生 StopIteration 时，程序该做的事情。如果没有发生异常，则 except 部分被跳过。</p>

<p>随后，程序将继续运行，而不是彻底中断。</p>

<p>完整的语法结构如下：</p>

<pre><code>try:
    ...
except exception1:
    ...
except exception2:
    ...
except:
    ...
else:
    ...
finally:
    ...
</code></pre>

<p>如果 try 中有异常发生时，将执行异常的归属，执行 except。异常层层比较，看是否是 <code>exception1, exception2...</code>，直到找到其归属，执行相应的 except 中的语句。如果 except 后面没有任何参数，那么表示所有的 exception 都交给这段程序处理。比如:</p>

<pre><code>try:
    print(a*2)
except TypeError:
    print("TypeError")
except:
    print("Not Type Error &amp; Error noted")
</code></pre>

<p>由于 a 没有定义，所以是 NameError。异常最终被 <code>except:</code> 部分的程序捕捉。</p>

<p>如果无法将异常交给合适的对象，异常将继续向上层抛出，直到被捕捉或者造成主程序报错。比如下面的程序：</p>

<pre><code>def test_func():
    try:
        m = 1/0
    except NameError:
        print("Catch NameError in the sub-function"
try:
    test_func()
except ZeroDivisionError:
    print("Catch error in the main program")
</code></pre>

<p>子程序的 <code>try...except...</code> 结构无法处理相应的除以0的错误，所以错误被抛给上层的主程序。</p>

<p>如果 try 中没有异常，那么 except 部分将跳过，执行 else 中的语句。</p>

<p>finally 是无论是否有异常，最后都要做的一些事情。</p>

<p>流程如下:</p>

<ul>
<li><p>try -> 异常 -> except -> finally</p></li>
<li><p>try -> 无异常 -> else -> finally</p></li>
</ul>


<h3>2、抛出异常</h3>

<p>我们也可以自己写一个抛出异常的例子:</p>

<pre><code>print 'Lalala'
raise StopIteration
print 'Hahaha'
</code></pre>

<p>这个例子不具备任何实际意义。只是为了说明 <code>raise</code> 语句的作用。</p>

<p>StopIteration 是一个类。抛出异常时，会自动有一个中间环节，就是生成 StopIteration 的一个对象。Python 实际上抛出的，是这个对象。当然，也可以自行生成对象:</p>

<pre><code>raise StopIteration()
</code></pre>

<h2>五、动态类型</h2>

<p>动态类型 (dynamic typing)V 是 Python 另一个重要的核心概念。我们之前说过，Python 的变量 (variable) 不需要声明，而在赋值时，变量可以重新赋值为任意值。这些都与动态类型的概念相关。</p>

<h3>1、动态类型</h3>

<p>在我们接触的对象中，有一类特殊的对象，是用于存储数据的。常见的该类对象包括各种数字，字符串，表，词典。在 C 语言中，我们称这样一些数据结构为变量。而在 Python 中，这些是对象。</p>

<p>对象是储存在内存中的实体。但我们并不能直接接触到该对象。我们在程序中写的对象名，只是指向这一对象的引用 (reference)。</p>

<p>引用和对象分离，是动态类型的核心。引用可以随时指向一个新的对象：</p>

<pre><code>a = 3
a = 'at'
</code></pre>

<p>第一个语句中，3是储存在内存中的一个整数对象。通过赋值，引用 a 指向对象3。</p>

<p>第二个语句中，内存中建立对象‘at’，是一个字符串(string)。引用 a 指向了'at'。此时，对象3不再有引用指向它。Python 会自动将没有引用指向的对象销毁(destruct)，释放相应内存。</p>

<p>(对于小的整数和短字符串，Python 会缓存这些对象，而不是频繁的建立和销毁。)</p>

<pre><code>a = 5
b = a
a = a + 2
</code></pre>

<p>再看这个例子。通过前两个句子，我们让 a,b 指向同一个整数对象5( b = a的含义是让引用b指向引用a所指的那一个对象)。但第三个句子实际上对引用a重新赋值，让a指向一个新的对象7。此时 a,b 分别指向不同的对象。我们看到，即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。从效果上看，就是各个引用各自独立，互不影响。</p>

<p>其它数据对象也是如此:</p>

<pre><code>L1 = [1,2,3]
L2 = L1
L1 = 1
</code></pre>

<p>但注意以下情况:</p>

<pre><code>L1 = [1,2,3]
L2 = L1
L1[0] = 10
print L2
</code></pre>

<p>在该情况下，我们不再对 L1 这一引用赋值，而是对 L1 所指向的表的元素赋值。结果是，L2 也同时发生变化。</p>

<p>原因何在呢？因为 L1，L2 的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如 L1[0]，L1[1]&hellip;, 每个引用指向一个对象，比如1,2,3), 。而 L1[0] = 10这一赋值操作，并不是改变L1的指向，而是对 L1[0], 也就是表对象的一部份(一个元素)，进行操作，所以所有指向该对象的引用都受到影响。</p>

<p>（与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。）</p>

<p>列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。</p>

<p>而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。</p>

<p>我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是 immutable object。</p>

<h3>2、从动态类型看函数的参数传递</h3>

<p>函数的参数传递，本质上传递的是引用。比如说：</p>

<pre><code>def f(x):
    x = 100
    print x

a = 1
f(a)
print a
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf2auvlvsj209w06gwf0.jpg" alt="img" /></p>

<p>参数 x 是一个新的引用，指向 a 所指的对象。如果参数是不可变(immutable)的对象，a 和 x 引用之间相互独立。对参数 x 的操作不会影响引用 a。这样的传递类似于 C 语言中的值传递。</p>

<p>如果传递的是可变(mutable)的对象，那么改变函数参数，有可能改变原对象。所有指向原对象的引用都会受影响，编程的时候要对此问题留心。比如说：</p>

<pre><code>def f(x):
    x[0] = 100
    print x
a = [1,2,3]
f(a)
print a
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etf2g38ta3j20e906vdgp.jpg" alt="img" /></p>

<p>动态类型是 Python 的核心机制之一。可以在应用中慢慢熟悉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 进阶-1]]></title>
    <link href="http://cnbin.github.io/blog/2015/06/25/python-jin-jie-1/"/>
    <updated>2015-06-25T09:43:29+08:00</updated>
    <id>http://cnbin.github.io/blog/2015/06/25/python-jin-jie-1</id>
    <content type="html"><![CDATA[<!--More-->


<h2>一、词典</h2>

<p>词典 (dictionary)与列表相似，词典也可以储存多个元素。这种储存多个元素的对象称为容器(container)。</p>

<p>1、基本概念</p>

<p>常见的创建词典的方法:</p>

<pre><code>&gt;&gt;&gt;dic = {'tom':11, 'sam':57,'lily':100}
&gt;&gt;&gt;print type(dic)
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etexwem3t7j20en03oab5.jpg" alt="img" /></p>

<p>词典和表类似的地方，是包含有多个元素，每个元素以逗号分隔。但词典的元素包含有两部分，键和值，常见的是以字符串来表示键，也可以使用数字或者真值来表示键（不可变的对象可以作为键）。值可以是任意对象。键和值两者一一对应。</p>

<p>比如上面的例子中，‘tom’ 对应11，'sam' 对应57，'lily' 对应100</p>

<p>与表不同的是，词典的元素没有顺序。你不能通过下标引用元素。词典是通过键来引用。</p>

<pre><code>&gt;&gt;&gt;print dic['tom']
&gt;&gt;&gt;dic['tom'] = 30
&gt;&gt;&gt;print dic
</code></pre>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etexylj1w8j20ei04s74v.jpg" alt="img" />
构建一个新的空的词典：</p>

<pre><code>&gt;&gt;&gt;dic = {}
&gt;&gt;&gt;print dic
</code></pre>

<p>在词典中增添一个新元素的方法：</p>

<pre><code>&gt;&gt;&gt;dic['lilei'] = 99
&gt;&gt;&gt;print dic
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etexzt1kpjj208103y3yo.jpg" alt="img" /></p>

<p>这里，我们引用一个新的键，并赋予它对应的值。</p>

<h3>2、词典元素的循环调用</h3>

<pre><code>dic = {'lilei': 90, 'lily': 100, 'sam': 57, 'tom': 90}
for key in dic:
    print dic[key]
</code></pre>

<p>在循环中，dict 的每个键，被提取出来，赋予给 key 变量。</p>

<p>通过 print 的结果，我们可以再次确认，dic 中的元素是没有顺序的。</p>

<h3>3、词典的常用方法</h3>

<pre><code>&gt;&gt;&gt;print dic.keys()           # 返回dic所有的键
&gt;&gt;&gt;print dic.values()         # 返回dic所有的值
&gt;&gt;&gt;print dic.items()          # 返回dic所有的元素（键值对）
&gt;&gt;&gt;dic.clear()                # 清空dic，dict变为{}
</code></pre>

<p>另外有一个很常用的用法：</p>

<pre><code>&gt;&gt;&gt;del dic['tom']             # 删除 dic 的‘tom’元素
</code></pre>

<p><code>del</code> 是 Python 中保留的关键字，用于删除对象。</p>

<p>与表类似，你可以用 <code>len()</code> 查询词典中的元素总数。</p>

<pre><code>&gt;&gt;&gt;print len(dic)
</code></pre>

<h2>二、文本文件的输入输出</h2>

<p>Python 具有基本的文本文件读写功能。Python 的标准库提供有更丰富的读写功能。</p>

<p>文本文件的读写主要通过 <code>open()</code> 所构建的文件对象来实现。</p>

<h3>1、创建文件对象</h3>

<p>我们打开一个文件，并使用一个对象来表示该文件：</p>

<pre><code>对象名 = open(文件名，模式)
</code></pre>

<p>最常用的模式有：</p>

<ul>
<li>r 打开只读文件，该文件必须存在。</li>
<li>r+ 打开可读写的文件，该文件必须存在。</li>
<li>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。</li>
<li>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。</li>
<li><p>上述的形态字符串都可以再加一个 b 字符，如 rb、w+b 或 ab＋ 等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。</p></li>
</ul>


<p>比如：</p>

<pre><code>&gt;&gt;&gt;f = open("test.txt","r")
</code></pre>

<h3>2、文件对象的方法</h3>

<p>读取：</p>

<pre><code>content = f.read(N)          # 读取N bytes的数据
content = f.readline()       # 读取一行
content = f.readlines()      # 读取所有行，储存在列表中，每个元素是一行。
</code></pre>

<p>写入：</p>

<pre><code>f.write('I like apple!\n')      # 将'I like apple'写入文件并换行
</code></pre>

<p>关闭文件：</p>

<pre><code>f.close()   # 不要忘记关闭文件
</code></pre>

<h2>三、模块</h2>

<p>我们之前看到了函数和对象。从本质上来说，它们都是为了更好的组织已经有的程序，以方便重复利用。</p>

<p>模块(module) 也是为了同样的目的。在 Python 中，一个 <code>.py</code> 文件就构成一个模块。通过模块，你可以调用其它文件中的程序。</p>

<h3>1、引入模块</h3>

<p>我们先写一个 <code>first.py</code> 文件，内容如下：</p>

<pre><code>def laugh():
    print 'HaHaHaHa'
</code></pre>

<p>再写一个 <code>second.py</code>，并引入 <code>first</code> 中的程序：</p>

<pre><code>import first   #将first文件引入 
for i in range(10):
    first.laugh()
</code></pre>

<p>在 <code>second.py</code> 中，我们使用了 <code>first.py</code> 中定义的 <code>laugh()</code> 函数。</p>

<p>引入模块后，可以通过 <code>模块.对象</code> 的方式来调用引入模块中的某个对象。上面例子中，first 为引入的模块，<code>laugh()</code> 是我们所引入的对象。</p>

<p>Python中 还有其它的引入方式：</p>

<pre><code>import a as b             # 引入模块a，并将模块a重命名为b
from a import function1   # 从模块a中引入function1对象。调用a中对象时，我们不用再说明模块，即直接使用function1，而不是a.function1。
from a import *           # 从模块a中引入所有对象。调用a中对象时，我们不用再说明模块，即直接使用对象，而不是a.对象。
</code></pre>

<p>这些引用方式，可以方便后面的程序书写。</p>

<h3>2、搜索路径</h3>

<p>Python会在以下路径中搜索它想要寻找的模块：</p>

<ul>
<li>程序所在的文件夹</li>
<li>操作系统环境变量 <code>PYTHONPATH</code> 所包含的路径</li>
<li>标准库的安装路径</li>
</ul>


<p>如果你有自定义的模块，或者下载的模块，可以根据情况放在相应的路径，以便 Python 可以找到。</p>

<h3>3、模块包</h3>

<p>可以将功能相似的模块放在同一个文件夹（比如说this_dir）中，构成一个模块包。通过</p>

<pre><code>import this_dir.module
</code></pre>

<p>引入 <code>this_dir</code> 文件夹中的 <code>module</code> 模块。</p>

<p>该文件夹中必须包含一个 <code>__init__.py</code> 的文件，提醒 <code>Python</code>，该文件夹为一个模块包。<code>__init__.py</code> 可以是一个空文件。</p>

<h2>四、函数的参数传递</h2>

<p>我们已经接触过函数(function)的参数(arguments)传递。当时我们根据位置，传递对应的参数。我们将接触更多的参数传递方式。</p>

<p>回忆一下位置传递：</p>

<pre><code>def f(a,b,c):
    return a+b+c、

print(f(1,2,3))
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etezy8accgj207v033wek.jpg" alt="img" /></p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etezy8z58wj20a200w748.jpg" alt="img" /></p>

<p>在调用 f 时，1，2，3 根据位置分别传递给了 <code>a,b,c</code> 。</p>

<h3>1、关键字传递</h3>

<p>有些情况下，用位置传递会感觉比较死板。关键字(keyword)传递是根据每个参数的名字传递参数。关键字并不用遵守位置的对应关系。依然沿用上面 f 的定义，更改调用方式：</p>

<pre><code>print(f(c=3,b=2,a=1))
</code></pre>

<p>关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：</p>

<pre><code>print(f(1,c=3,b=2))
</code></pre>

<h3>2、参数默认值</h3>

<p>在定义函数的时候，使用形如 <code>a=19</code> 的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。</p>

<pre><code>def f(a,b,c=10):
    return a+b+c
print(f(3,2))
print(f(3,2,1))
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etf019kjjpj207x034glt.jpg" alt="img" /></p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1etf00e1c52j209j01gweg.jpg" alt="img" />
在第一次调用函数f时， 我们并没有足够的值，c 没有被赋值，c 将使用默认值10.</p>

<p>第二次调用函数的时候，c 被赋值为1，不再使用默认值。</p>

<h3>3、包裹传递</h3>

<p>在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。</p>

<p>下面是包裹位置传递的例子：</p>

<pre><code>def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3)
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etezs589uuj209p04aglx.jpg" alt="img" /></p>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1etezs5s4s9j20ah02faa9.jpg" alt="img" /></p>

<p>两次调用，尽管参数个数不同，都基于同一个 <code>func</code> 定义。在 <code>func</code> 的参数表中，所有的参数被 <code>name</code> 收集，根据位置合并成一个元组(tuple)，这就是包裹位置传递。</p>

<p>为了提醒 <code>Python</code> 参数，<code>name</code> 是包裹位置传递所用的元组名，在定义 <code>func</code> 时，在 <code>name</code> 前加 <code>*</code> 号。</p>

<p>下面是包裹关键字传递的例子：</p>

<pre><code>def func(**dict):
    print type(dict)
    print dict
func(a=1,b=9)
func(m=2,n=1,c=11)
</code></pre>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1etezuql1iuj207i03rwes.jpg" alt="img" /></p>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etezutp89tj208w02aweq.jpg" alt="img" /></p>

<p>与上面一个例子类似，dict 是一个字典，收集所有的关键字，传递给函数 func。为了提醒 Python，参数 dict 是包裹关键字传递所用的字典，在 dict 前加。</p>

<p>包裹传递的关键在于定义函数时，在相应元组或字典前加或<code>*</code>。</p>

<h3>4、解包裹</h3>

<p><code>*</code> 和 <code>**</code>，也可以在调用的时候使用，即解包裹(unpacking), 下面为例：</p>

<pre><code>def func(a,b,c):
    print a,b,c
args = (1,3,4)
func(*args)
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1eteza3nwf6j209701laa4.jpg" alt="img" /></p>

<p>在这个例子中，所谓的解包裹，就是在传递 tuple 时，让 tuple 的每一个元素对应一个位置参数。在调用 func 时使用 <code>*</code> ，是为了提醒 Python：我想要把 args 拆成分散的三个元素，分别传递给 a,b,c。（设想一下在调用 func 时，args 前面没有 <code>*</code> 会是什么后果？）</p>

<p>相应的，也存在对词典的解包裹，使用相同的 func 定义，然后：</p>

<pre><code>def func(a,b,c):
    print a,b,c
dict = {'a':1,'b':2,'c':3}
func(**dict)
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw690/78f9859egw1etezdq2blbj209i00tq2w.jpg" alt="img" /></p>

<p>在传递词典 <code>dict</code> 时，让词典的每个键值对作为一个关键字传递给 <code>func</code>。</p>

<h3>5、混合</h3>

<p>在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是：先位置，再关键字，再包裹位置，再包裹关键字，并且根据上面所说的原理细细分辨。</p>

<p>注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。</p>
]]></content>
  </entry>
  
</feed>
