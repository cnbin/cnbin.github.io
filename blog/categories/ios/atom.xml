<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 陈斌彬的技术博客]]></title>
  <link href="http://cnbin.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://cnbin.github.io/"/>
  <updated>2016-08-18T18:05:24+08:00</updated>
  <id>http://cnbin.github.io/</id>
  <author>
    <name><![CDATA[陈斌彬]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xcode 插件]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/16/xcode-cha-jian/"/>
    <updated>2016-08-16T06:58:29+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/16/xcode-cha-jian</id>
    <content type="html"><![CDATA[<!--More-->


<p>MLAutoReplace <a href="https://github.com/molon/MLAutoReplace">https://github.com/molon/MLAutoReplace</a></p>

<p>Auto-Importer-for-Xcode <a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode">https://github.com/citrusbyte/Auto-Importer-for-Xcode</a></p>

<p>Cichlid <a href="https://github.com/dealforest/Cichlid">https://github.com/dealforest/Cichlid</a></p>

<p>CleanHeaders-Xcode <a href="https://github.com/insanoid/CleanHeaders-Xcode">https://github.com/insanoid/CleanHeaders-Xcode</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目适配iOS9遇到的一些问题及解决办法（更新两个小问题）]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/15/xiang-mu-gua-pei-ios9yu-dao-de-xie-wen-ti-ji-jie-jue-ban-fa-geng-xin-liang-ge-xiao-wen-ti/"/>
    <updated>2016-08-15T08:57:28+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/15/xiang-mu-gua-pei-ios9yu-dao-de-xie-wen-ti-ji-jie-jue-ban-fa-geng-xin-liang-ge-xiao-wen-ti</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://www.jianshu.com/p/631bd7f12a38">http://www.jianshu.com/p/631bd7f12a38</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios与web交互]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/11/iosyu-webjiao-hu/"/>
    <updated>2016-08-11T14:48:11+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/11/iosyu-webjiao-hu</id>
    <content type="html"><![CDATA[<!--More-->


<p>web html文件加上scipt</p>

<pre><code> &lt;script&gt;
            (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
            function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
            e=o.createElement(i);r=o.getElementsByTagName(i)[0];
            e.src='https://www.google-analytics.com/analytics.js';
            r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
            ga('create','UA-XXXXX-X','auto');ga('send','pageview');
        &lt;/script&gt;
        &lt;script&gt;

            function pushSubViewController () {
                setupWebViewJavascriptBridge(function(bridge) {
                    bridge.callHandler('push',
                        {
                            'detailID': '斌彬哥哥',
                            'actionName':'push'
                        },
                        function responseCallback(responseData) {
                            console.log("JS received response:", responseData)
                        })
                })
            }

        &lt;/script&gt;
        &lt;script&gt;
            //        init JS  //固定写法
            window.onerror = function(err) {
                log('window.onerror: ' + err)
            }

            function setupWebViewJavascriptBridge(callback) {
                if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }
                if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }
                window.WVJBCallbacks = [callback];
                var WVJBIframe = document.createElement('iframe');
                WVJBIframe.style.display = 'none';
                WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';
                document.documentElement.appendChild(WVJBIframe);
                setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)
            }
        &lt;/script&gt;

            &lt;p&gt;3.跳转到某些子界面&lt;/p&gt;
        &lt;button id="push" onclick="pushSubViewController()"&gt;pushSubViewController&lt;/button&gt;
</code></pre>

<p>ios端导入</p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1f6pt4darjoj207706saaz.jpg" alt="img" /></p>

<p>导入</p>

<pre><code>#import "WebViewJavascriptBridge.h"
#import "HybirdUrlHandler.h"
#import "HyBridBridge.h"
</code></pre>

<p>添加</p>

<pre><code>@property WebViewJavascriptBridge *bridge;
@property (strong, nonatomic) HyBridBridge *hybridBridge;
</code></pre>

<p>使用</p>

<pre><code>[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:@"http://localhost:8080/src/"]]]];

//http://localhost:8080/src/
//http://ionic-person-6e53.coding.io/
_bridge = [WebViewJavascriptBridge bridgeForWebView:webView];
[self.hybridBridge registerHybridUrlHanlder:self andBridge:self.bridge];
</code></pre>

<p>回调</p>

<pre><code>//懒加载
- (HyBridBridge *)hybridBridge {
    if (!_hybridBridge) {
        _hybridBridge = [[HyBridBridge alloc] init];
    }
    return _hybridBridge;
}

- (NSArray *)actionNames {  //定义可支持的方法名称
    return @[@"push"];
}

//HTML 部分 需要定义 方法名称
//传参的时候 带上方法名字  我这里写的是actionName
- (BOOL)handleDictionAry:(NSDictionary *)dictionary callback:(HybridCallbackBlock)callbackBlock {
    NSString *actionTag = dictionary[@"actionName"];

    if ([actionTag isEqualToString:@"push"]) {

        NSString *detailID = dictionary[@"detailID"];
        NSLog(@"detailID is %@",detailID);
        NSLog(@"push view controller");
        BBZhiFuViewController *vc = [[BBZhiFuViewController alloc]init];
        vc.detailID = detailID;
        [self.navigationController pushViewController:vc animated:YES];
        return YES;
    }
    return NO;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC与swift相互调用]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/09/ocyu-swiftxiang-hu-diao-yong/"/>
    <updated>2016-08-09T14:47:51+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/09/ocyu-swiftxiang-hu-diao-yong</id>
    <content type="html"><![CDATA[<!--More-->


<p>一、OC调用swift文件</p>

<p>二、swift调用OC文件</p>

<p>三、注意和总结</p>

<p>添加：</p>

<p>四、自定义桥接文件</p>

<p>一、OC调用swift文件</p>

<p>在OC项目中创建一个swift文件的时候，Xcode 会提示 需要创建一个桥接文件，点确定创建桥接文件，Xcode会自动创建一个桥接文件</p>

<p>名字：工程名-Bridging-Header.h</p>

<p>这个桥接文件是 swift 调用OC文件的时候用的</p>

<p>1、
进入TARGETS ->Build Settings -> Packaging 中</p>

<p>设置Defines Module为YES</p>

<p>设置 Product Module Name ，也可以不设置，默认为工程的名字。这个在后面会用到</p>

<p>2、
在swift写一个类</p>

<p>注意这个类一定要继承NSObject，不然在OC中没法用</p>

<p>class hello: NSObject {</p>

<pre><code>var address : String
var gender: String

init(address:String,gender:String){
    self.address = address
    self.gender = gender
}

func method() {
    print("message \(self.address + self.gender)")
}
}
</code></pre>

<p>3、
　　在OC需要用到的swift文件中 导入文件 &ldquo;Product Module Name -Swift.h&rdquo;  因为 Product Module Name 默认是工程的名字</p>

<p>所以直接导入 #import &ldquo;工程名-Swift.h&rdquo;</p>

<p>4、
　　记着写完先command +B编译一下，如果没有报错就可以在OC文件调用swift中的类了</p>

<p>hello *helloss = [[helloalloc]initWithAddress:@&ldquo;上海"gender:@"男&rdquo;];
[helloss method];</p>

<p>二、swift调用OC文件
　　在swift项目中创建一个OC文件的时候，Xcode 会提示创建一个桥接文件 点确定创建桥接文件，Xcode会自动创建一个桥接文件</p>

<p>名字：工程名-Bridging-Header.h</p>

<p>　　把swift需要用到的OC文件的头文件放到桥接文件里 工程名-Bridging-Header.h</p>

<p>例如：</p>

<p>1、
这个就是一个OC文件</p>

<pre><code>//#import "sec.h"
#import &lt;UIKit/UIKit.h&gt;
@interface sec : UIViewController
-(void)actionMake;
@end
</code></pre>

<p>2、
在桥接文件中把需要用到OC的头文件导入进去</p>

<pre><code>#import "sec.h"
</code></pre>

<p>3、
编译一下，就可以在swift中用swift的语法调用OC文件的方法了</p>

<pre><code>let second = sec()
second.actionMake()
</code></pre>

<p>三、注意和总结</p>

<p>注意：
1、OC项目在导入swift文件前 先按照系统提示创建桥接文件，</p>

<p>2、在 targets -> Build Settings -> Packaging  中设置Defines Module 为YES</p>

<p>3、在OC中调用swift文件的时候，swift中的类 要继承NSObject</p>

<p>不然没办法在OC中调用</p>

<p>4、OC中调用swift文件需要导入”工程名 -Swift.h"</p>

<p>（这个是build Setting -> Packaging->Product Module Name 的名字，而这个属性默认是工程的名字）</p>

<p>5、写完记得command + B 编译 一下</p>

<p>6、swift项目 引用OC文件也需要创建 桥接文件，在这个桥接文件中导入OC文件的头文件</p>

<p>7、桥接文件只有一个，作用只是为了 swift 引用OC文件，OC引用swift 文件虽然也需要创建桥接文件
        但是不需要在桥接文件中 导入swift文件</p>

<p>8、如果一个项目既有OC引用swift 也有swift引用OC ,就先设置OC调用swift文件
     在桥接文件 导入OC文件，OC可以定义PCH文件导入”工程名 -Swift.h"</p>

<p>四、自定义桥接文件</p>

<p>如果不用Xcode提示创建桥接文件也可以自定义一个桥接文件</p>

<p>1  使用 Header File  把里面的内容清空。</p>

<p>2、 这文件名可以自定义， 一般还是用 工程名-Bridging-Header.h   例如app - file.h</p>

<p>3    然后在 Build Setting -> Swift Compiler - Code Generation中</p>

<p>4、设置Objective-C Bridging Header 为自定义的桥接文件相对于工程的绝对路径，也就是项目总文件夹的路径，如果在第一层，就直接写自定义的桥接文件的名file.h，如果在下一层，文件夹/桥接文件 app/file.h</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://www.cnblogs.com/mazhiqiang/p/5557002.html">http://www.cnblogs.com/mazhiqiang/p/5557002.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下ionic调试]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi/"/>
    <updated>2016-08-08T15:36:54+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://my.oschina.net/twinkling/blog/504824?p={{totalPage}}">http://my.oschina.net/twinkling/blog/504824?p={{totalPage}}</a></h3>
]]></content>
  </entry>
  
</feed>
