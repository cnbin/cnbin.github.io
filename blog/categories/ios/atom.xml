<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 陈斌彬的技术博客]]></title>
  <link href="http://cnbin.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://cnbin.github.io/"/>
  <updated>2016-08-11T14:52:44+08:00</updated>
  <id>http://cnbin.github.io/</id>
  <author>
    <name><![CDATA[陈斌彬]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ios与web交互]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/11/iosyu-webjiao-hu/"/>
    <updated>2016-08-11T14:48:11+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/11/iosyu-webjiao-hu</id>
    <content type="html"><![CDATA[<!--More-->


<p>web html文件加上scipt</p>

<pre><code> &lt;script&gt;
            (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
            function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
            e=o.createElement(i);r=o.getElementsByTagName(i)[0];
            e.src='https://www.google-analytics.com/analytics.js';
            r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
            ga('create','UA-XXXXX-X','auto');ga('send','pageview');
        &lt;/script&gt;
        &lt;script&gt;

            function pushSubViewController () {
                setupWebViewJavascriptBridge(function(bridge) {
                    bridge.callHandler('push',
                        {
                            'detailID': '斌彬哥哥',
                            'actionName':'push'
                        },
                        function responseCallback(responseData) {
                            console.log("JS received response:", responseData)
                        })
                })
            }

        &lt;/script&gt;
        &lt;script&gt;
            //        init JS  //固定写法
            window.onerror = function(err) {
                log('window.onerror: ' + err)
            }

            function setupWebViewJavascriptBridge(callback) {
                if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }
                if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }
                window.WVJBCallbacks = [callback];
                var WVJBIframe = document.createElement('iframe');
                WVJBIframe.style.display = 'none';
                WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';
                document.documentElement.appendChild(WVJBIframe);
                setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)
            }
        &lt;/script&gt;

            &lt;p&gt;3.跳转到某些子界面&lt;/p&gt;
        &lt;button id="push" onclick="pushSubViewController()"&gt;pushSubViewController&lt;/button&gt;
</code></pre>

<p>ios端导入</p>

<p><img src="http://ww2.sinaimg.cn/mw690/78f9859egw1f6pt4darjoj207706saaz.jpg" alt="img" /></p>

<p>导入</p>

<pre><code>#import "WebViewJavascriptBridge.h"
#import "HybirdUrlHandler.h"
#import "HyBridBridge.h"
</code></pre>

<p>添加</p>

<pre><code>@property WebViewJavascriptBridge *bridge;
@property (strong, nonatomic) HyBridBridge *hybridBridge;
</code></pre>

<p>使用</p>

<pre><code>[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:@"http://localhost:8080/src/"]]]];

//http://localhost:8080/src/
//http://ionic-person-6e53.coding.io/
_bridge = [WebViewJavascriptBridge bridgeForWebView:webView];
[self.hybridBridge registerHybridUrlHanlder:self andBridge:self.bridge];
</code></pre>

<p>回调</p>

<pre><code>//懒加载
- (HyBridBridge *)hybridBridge {
    if (!_hybridBridge) {
        _hybridBridge = [[HyBridBridge alloc] init];
    }
    return _hybridBridge;
}

- (NSArray *)actionNames {  //定义可支持的方法名称
    return @[@"push"];
}

//HTML 部分 需要定义 方法名称
//传参的时候 带上方法名字  我这里写的是actionName
- (BOOL)handleDictionAry:(NSDictionary *)dictionary callback:(HybridCallbackBlock)callbackBlock {
    NSString *actionTag = dictionary[@"actionName"];

    if ([actionTag isEqualToString:@"push"]) {

        NSString *detailID = dictionary[@"detailID"];
        NSLog(@"detailID is %@",detailID);
        NSLog(@"push view controller");
        BBZhiFuViewController *vc = [[BBZhiFuViewController alloc]init];
        vc.detailID = detailID;
        [self.navigationController pushViewController:vc animated:YES];
        return YES;
    }
    return NO;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC与swift相互调用]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/09/ocyu-swiftxiang-hu-diao-yong/"/>
    <updated>2016-08-09T14:47:51+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/09/ocyu-swiftxiang-hu-diao-yong</id>
    <content type="html"><![CDATA[<!--More-->


<p>一、OC调用swift文件</p>

<p>二、swift调用OC文件</p>

<p>三、注意和总结</p>

<p>添加：</p>

<p>四、自定义桥接文件</p>

<p>一、OC调用swift文件</p>

<p>在OC项目中创建一个swift文件的时候，Xcode 会提示 需要创建一个桥接文件，点确定创建桥接文件，Xcode会自动创建一个桥接文件</p>

<p>名字：工程名-Bridging-Header.h</p>

<p>这个桥接文件是 swift 调用OC文件的时候用的</p>

<p>1、
进入TARGETS ->Build Settings -> Packaging 中</p>

<p>设置Defines Module为YES</p>

<p>设置 Product Module Name ，也可以不设置，默认为工程的名字。这个在后面会用到</p>

<p>2、
在swift写一个类</p>

<p>注意这个类一定要继承NSObject，不然在OC中没法用</p>

<p>class hello: NSObject {</p>

<pre><code>var address : String
var gender: String

init(address:String,gender:String){
    self.address = address
    self.gender = gender
}

func method() {
    print("message \(self.address + self.gender)")
}
}
</code></pre>

<p>3、
　　在OC需要用到的swift文件中 导入文件 &ldquo;Product Module Name -Swift.h&rdquo;  因为 Product Module Name 默认是工程的名字</p>

<p>所以直接导入 #import &ldquo;工程名-Swift.h&rdquo;</p>

<p>4、
　　记着写完先command +B编译一下，如果没有报错就可以在OC文件调用swift中的类了</p>

<p>hello *helloss = [[helloalloc]initWithAddress:@&ldquo;上海"gender:@"男&rdquo;];
[helloss method];</p>

<p>二、swift调用OC文件
　　在swift项目中创建一个OC文件的时候，Xcode 会提示创建一个桥接文件 点确定创建桥接文件，Xcode会自动创建一个桥接文件</p>

<p>名字：工程名-Bridging-Header.h</p>

<p>　　把swift需要用到的OC文件的头文件放到桥接文件里 工程名-Bridging-Header.h</p>

<p>例如：</p>

<p>1、
这个就是一个OC文件</p>

<pre><code>//#import "sec.h"
#import &lt;UIKit/UIKit.h&gt;
@interface sec : UIViewController
-(void)actionMake;
@end
</code></pre>

<p>2、
在桥接文件中把需要用到OC的头文件导入进去</p>

<pre><code>#import "sec.h"
</code></pre>

<p>3、
编译一下，就可以在swift中用swift的语法调用OC文件的方法了</p>

<pre><code>let second = sec()
second.actionMake()
</code></pre>

<p>三、注意和总结</p>

<p>注意：
1、OC项目在导入swift文件前 先按照系统提示创建桥接文件，</p>

<p>2、在 targets -> Build Settings -> Packaging  中设置Defines Module 为YES</p>

<p>3、在OC中调用swift文件的时候，swift中的类 要继承NSObject</p>

<p>不然没办法在OC中调用</p>

<p>4、OC中调用swift文件需要导入”工程名 -Swift.h"</p>

<p>（这个是build Setting -> Packaging->Product Module Name 的名字，而这个属性默认是工程的名字）</p>

<p>5、写完记得command + B 编译 一下</p>

<p>6、swift项目 引用OC文件也需要创建 桥接文件，在这个桥接文件中导入OC文件的头文件</p>

<p>7、桥接文件只有一个，作用只是为了 swift 引用OC文件，OC引用swift 文件虽然也需要创建桥接文件
        但是不需要在桥接文件中 导入swift文件</p>

<p>8、如果一个项目既有OC引用swift 也有swift引用OC ,就先设置OC调用swift文件
     在桥接文件 导入OC文件，OC可以定义PCH文件导入”工程名 -Swift.h"</p>

<p>四、自定义桥接文件</p>

<p>如果不用Xcode提示创建桥接文件也可以自定义一个桥接文件</p>

<p>1  使用 Header File  把里面的内容清空。</p>

<p>2、 这文件名可以自定义， 一般还是用 工程名-Bridging-Header.h   例如app - file.h</p>

<p>3    然后在 Build Setting -> Swift Compiler - Code Generation中</p>

<p>4、设置Objective-C Bridging Header 为自定义的桥接文件相对于工程的绝对路径，也就是项目总文件夹的路径，如果在第一层，就直接写自定义的桥接文件的名file.h，如果在下一层，文件夹/桥接文件 app/file.h</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://www.cnblogs.com/mazhiqiang/p/5557002.html">http://www.cnblogs.com/mazhiqiang/p/5557002.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下ionic调试]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi/"/>
    <updated>2016-08-08T15:36:54+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://my.oschina.net/twinkling/blog/504824?p=">http://my.oschina.net/twinkling/blog/504824?p=</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebview 的缓存策略和验证，以及 Web 相关]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/uiwebview-de-huan-cun-ce-lue-he-yan-zheng-,yi-ji-web-xiang-guan/"/>
    <updated>2016-08-08T08:25:11+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/uiwebview-de-huan-cun-ce-lue-he-yan-zheng-,yi-ji-web-xiang-guan</id>
    <content type="html"><![CDATA[<!--More-->


<p>缓存策略 NSURLRequestCachePolicy</p>

<p>NSURLRequestUseProtocolCachePolicy
缓存策略定义在 web 协议实现中，用于请求特定的URL。是默认的URL缓存策略
Specifies that the caching logic defined in the protocol implementation, if any, is used for a particular URL load request. This is the default policy for URL load requests.</p>

<p>NSURLRequestReloadIgnoringLocalCacheData
从服务端获取数据，忽略本地缓存</p>

<p>Specifies that the data for the URL load should be loaded from the originating source. No existing cache data should be used to satisfy a URL load request.</p>

<p>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</p>

<p>不仅忽略本地的缓存数据，还忽略中间网络媒介（如代理服务器）忽略缓存。直接从最原始的服务器拿取
Specifies that not only should the local cache data be ignored, but that proxies and other intermediates should be instructed to disregard their caches so far as the protocol allows.</p>

<p>NSURLRequestReloadIgnoringCacheData
被NSURLRequestReloadIgnoringLocalCacheData替换了</p>

<p>Replaced by NSURLRequestReloadIgnoringLocalCacheData.</p>

<p>NSURLRequestReturnCacheDataElseLoad</p>

<p>已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，从数据源读取
Specifies that the existing cached data should be used to satisfy the request, regardless of its age or expiration date. If there is no existing data in the cache corresponding the request, the data is loaded from the originating source.</p>

<p>NSURLRequestReturnCacheDataDontLoad</p>

<p>已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，不要去数据源读取，该请求被设置为失败，这种情况多用于离线模式</p>

<p>Specifies that the existing cache data should be used to satisfy a request, regardless of its age or expiration date. If there is no existing data in the cache corresponding to a URL load request, no attempt is made to load the data from the originating source, and the load is considered to have failed. This constant specifies a behavior that is similar to an “offline” mode.</p>

<p>NSURLRequestReloadRevalidatingCacheData</p>

<p>已经存在的缓存数据先去数据源验证有效性，如果无效，将从数据源获取
Specifies that the existing cache data may be used provided the origin source confirms its validity, otherwise the URL is loaded from the origin source.</p>

<p>NSURLRequestUseProtocolCachePolicy 和 NSURLRequestReloadRevalidatingCacheData 区别</p>

<p>个人意见，仅供参考，如有错误，请指出来，这对我很重要，谢谢</p>

<p>NSURLRequestReloadRevalidatingCacheData 是一定要和原始的数据源验证 cache 是否有效。
而NSURLRequestUseProtocolCachePolicy 是根据 web 的协议来控制缓存，服务端返回数据的 head 有相关的信息。它可能会返回中间网络媒介（如代理服务器中的数据）</p>

<p>针对缓存策略做一下本地测试，这是非常有必要的</p>

<pre><code>NSURL *webUrl = [NSURL URLWithString:@"http://localhost/test.txt"];       
NSURLRequest *request =[NSURLRequest requestWithURL:webUrl cachePolicy:NSURLRequestReloadRevalidatingCacheData timeoutInterval:60];       
[self.mainWebView loadRequest:request];  
</code></pre>

<p>这里使用NSURLRequestReloadRevalidatingCacheData， 返回cache数据一定要先验证数据有效。</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/mangosnow/article/details/37831529">http://blog.csdn.net/mangosnow/article/details/37831529</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FKConsole - Xcode控制台中文显示调整插件]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/04/fkconsole-xcodekong-zhi-tai-zhong-wen-xian-shi-diao-zheng-cha-jian/"/>
    <updated>2016-08-04T08:13:32+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/04/fkconsole-xcodekong-zhi-tai-zhong-wen-xian-shi-diao-zheng-cha-jian</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://www.tuicool.com/articles/yUjaYv">http://www.tuicool.com/articles/yUjaYv</a></h3>
]]></content>
  </entry>
  
</feed>
