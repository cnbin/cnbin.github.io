
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Jabber 协议概述(原创) - 陈斌彬的技术博客</title>
  <meta name="author" content="陈斌彬">

  
  <meta name="description" content="1. 介绍 Jabber 是一个由开源社区发起并领导开发的即时消息和在线状态的系统。Jabber 系统和其它即时消息服务(IM)的一个功能上的差别在于 Jabber 拥有开放的 XML 协议。在保持 Jabber1.0 版本有关消息核心以及在线状态的协议的基础上，增加了一些必要的扩展。本文档将对 &hellip;">
  <meta name="keywords" content="jabber">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://cnbin.github.io/blog/2015/06/30/jabber-xie-yi-gai-shu/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="陈斌彬的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">陈斌彬的技术博客</a></h1>
  
    <h2>Stay foolish,stay hungry</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="cnbin.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation"> 
  <li><a href="/">首页</a></li> 
  <li><a href="/blog/archives">归档</a></li> 
  <li><a href="/about">关于</a></li> 
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Jabber 协议概述(原创)</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-30T11:16:06+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:16 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><!--More-->


<h2>1. 介绍</h2>

<p><strong>Jabber</strong> 是一个由开源社区发起并领导开发的即时消息和在线状态的系统。Jabber 系统和其它即时消息服务(IM)的一个功能上的差别在于 Jabber 拥有开放的 XML 协议。在保持 Jabber1.0 版本有关消息核心以及在线状态的协议的基础上，增加了一些必要的扩展。本文档将对 Jabber 服务器 1.4 版的 Jabber 协议进行介绍。</p>

<p>在 XML 上下文的数据流中，Jabber 开放的 XML 协议包括三个顶级 XML 元素：</p>

<ul>
<li><p><code>&lt;message/&gt;</code></p></li>
<li><p><code>&lt;presence/&gt;</code></p></li>
<li><p><code>&lt;iq/&gt;(info/query)</code></p></li>
</ul>


<p>每一个元素通过属性和名字空间包含大量的数据，这些属性和名字空间都是 <code>Jabber</code> 的组成部分（但不包括为特殊应用的名字空间应用）。下面将描述整个 Jabber 协议。如果您想获得关于 Jabber 系统结构的信息，请查看名为 Jabber 技术概述的文档（<a href="http://docs.jabber.org/general/html/overview.html">http://docs.jabber.org/general/html/overview.html</a>）。</p>

<h2>2. XML流</h2>

<p> 一个 Jabber 会话由两个平行的 XML 流组成，一个从客户端到服务器端，另一个从服务端到客户端。当一个 Jabber 客户端连接上一个 Jabber 服务器时，这个客户端将发起一个<code>客户端－服务器</code>的 XML 流，同时作为响应，服务器也将发起一个<code>服务器－客户端</code>的 XML 流。所有<code>&lt;message/&gt;</code>，<code>&lt;presence/&gt;</code>，以及<code>&lt;iq/&gt;</code>元素都被放在这些 XML 流的上下文中。下面就有一个例子：</p>

<pre><code>SEND:&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;
SEND:&lt;stream:stream
SEND:to=’jabber.org’
SEND:xmlns=’jabber:client’
SEND:xmlns:stream=’http://ether.jabber.org/streams’&gt;
RECV:&lt;stream:stream
RECV:xmlns:stream=’http://etherx.jabber.org/streams’
RECV:id=’39ABA7D2’
RECV:xmlns=’jabber:client’
RECV:from=’jabber.org’&gt;
(XML for user session goes here)*
SEND:&lt;/stream:stream&gt;
RECV:&lt;/stream:stream&gt;
</code></pre>

<p>*注意：必须等到当一个 <code>&lt;iq/&gt;</code>元素（特别指一个 <code>jabber:iq:auth</code> 名字空间下的 <code>&lt;query/&gt;</code> 元素）发送了认证信息后，服务器才会同意用户会话进行工作。</p>

<h2>3. &lt;message/> 元素</h2>

<p><code>&lt;message/&gt;</code> 元素是 Jabber 开放 XML 协议三个顶级元素中的一个。它被用来包含两个 Jabber 用户间互相发送消息内容，或者两个 <code>Jabber IDs</code> 之间更一般的消息（因为，通过神奇的传输器，另一个 <code>IM</code> 系统可以用 <code>Jabber ID</code> 代替，如<code>70902454@icq.jabber.org</code>）。</p>

<h3>3.1. 消息类型－"type"属性</h3>

<p>Jabber 支持几种不同的消息，这些消息通过<code>&lt;message/&gt;</code>的<code>type</code>属性来进行区分。下面就是<code>type</code>属性的有效值：</p>

<h4>3.1.1. [default]（不设置"type"属性）</h4>

<p> 表示本消息是一个普通消息。默认的情况下，客户端在没有设置属性时，将消息类型定为普通消息。</p>

<p>例子：</p>

<pre><code>&lt;message to="romeo@montague.net/orchard"&gt;
&lt;body&gt;Wherefore art though Romeo?&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h4>3.1.2.type=&ldquo;chat&rdquo;</h4>

<p>表示消息需要被一个接一个的显示在聊天界面上（一般是一条接一条的界面，不过实际界面可以被用户自己定义。）</p>

<p>例子：</p>

<pre><code>&lt;message to="romeo@montague.net/orchard" type="chat"&gt;
&lt;body&gt;Wherefore art though Romeo?&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h4>3.1.3.type=&ldquo;error&rdquo;</h4>

<p>表示消息被描述成一个错误条件。实际的错误在消息中用一个 <code>&lt;error/&gt;</code> 元素来描述。一个 <code>&lt;message/&gt;</code> 元素包括一个 <code>&lt;body/&gt;</code> 和一个 <code>&lt;error/&gt;</code> 。下面的例子将演示，当 Juliet 对一个不存在的用户发送一个 <code>hi</code> 的消息时，将收到的包体：</p>

<p>例子：</p>

<pre><code>&lt;message
to="juliet@capulet.com"
from="flomeo@montague.net"
type="error"&gt;
&lt;body&gt;hi&lt;/body&gt;
&lt;error code="404"&gt;Not Found&lt;/error&gt;
&lt;/message&gt;
</code></pre>

<h4>3.1.4. type=&ldquo;groupchat&rdquo;</h4>

<p>表示本消息需要在一个聊天室的界面中进行显示。</p>

<p>例子：</p>

<pre><code>&lt;message to="cauldron@conference.witches.org" type="groupchat"&gt;
&lt;body&gt;Double, double toil and trouble&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h3>3.2. &lt;message/>其它属性</h3>

<p>除了设置 <code>type</code> 属性，还可以通过下面的属性修改 <code>&lt;message/&gt;</code> 元素：</p>

<h4>3.2.1. &ldquo;from"属性</h4>

<p>消息发送者的标志。总得来说，<code>Jabber ID</code>的 <code>from</code> 必须是 <code>user@host/resource</code> 的格式。从 <code>XML</code> 的观点来说，这个属性必须包含于所有的 <code>&lt;message/&gt;</code> 元素中，为了对付一些欺骗，实际应用中服务器添加或置换这个属性。因此，它并不是客户端开发者需要关心的问题。</p>

<p> 例子：</p>

<pre><code>&lt;message from="juliet@capulet.com/balcony"&gt;
&lt;body&gt;Wherefore art thou Romeo?&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h4>3.2.2. &ldquo;id"属性</h4>

<p><code>id</code> 属性是作为消息的一个唯一标志。它由 Jabber 客户端或客户库（类似 WinJab 或 JabberCOM ），生成，客户端用它来为跟踪消息（比如将发送到一个群组聊天室的信息和从这个聊天室收到的消息相关联，或将一个消息与它可能产生的错误相关联）进行标识。<code>id</code> 属性是可选的，并且在系统的别的方是不可用的。
例子：</p>

<pre><code>&lt;message to="romeo@montague.net/orchard" id="JCOM_85"&gt;
&lt;body&gt;Wherefore art thou Romeo?&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h4>3.2.3. &ldquo;to"属性</h4>

<p>表示消息的接收者。Jabber ID 的 <code>to</code> 属性一般是 <code>user@host/resource</code> 格式，<code>user@host</code> 也可以被接受。如果接收者在线，通过 <code>user@host/resource</code> 方式解决，如果用户不在线，直接发送离线存储器。这个属性是所有 <code>&lt;message/&gt;</code> 元素必须的。
例子：</p>

<pre><code>&lt;message to="romeo@montague.net/orchard"&gt;
&lt;body&gt;Wherefore art thou Romeo?&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h3>3.3. &lt;message/>中的子元素</h3>

<p>下面的子元素是用来定义一个 Jabber 消息的上下文或数据元。</p>

<h4>3.3.1. &lt;body/></h4>

<p>这个元素包含消息的主要文本。<code>&lt;body/&gt;</code> 元素只存在于一个 <code>&lt;message/&gt;</code> 元素中，并且只能包含明文。不过，它可以由其它子元素构成（如 <code>&lt;error/&gt;</code>、<code>&lt;x/&gt;</code>）。</p>

<h4>3.3.2. &lt;error/></h4>

<p>当消息类型属性被置为 <code>error</code> 时，这个元素将被使用。错误代码被一个 <code>type</code> 属性定义，这个<code>type</code>属性包含代码数，通过 <code>&lt;error/&gt;</code> 元素来包含一个这个错误的文本描述。<code>&lt;error/&gt;</code> 元素必须包含在原始消息的 <code>&lt;body/&gt;</code> 中。下面的例子将演示，当 Juliet 向一个不存在的用户发送 <code>hi</code> 消息后的包体：</p>

<p>例子：</p>

<pre><code>&lt;message
to="juliet@capulet.com"
from="flomeo@montague.net"
type="error"&gt;
&lt;body&gt;hi&lt;/body&gt;
&lt;error code="404"&gt;Not Found&lt;/error&gt;
&lt;/message&gt;
</code></pre>

<p>附文中有非法代码与它们所定义的含义表。</p>

<h4>3.3.3. &lt;html/></h4>

<p><code>&lt;html/&gt;</code> 元素结合 <code>XHTML</code> 名字空间（<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>），为一个消息提供一个交替的名字空间，就像在 email 世界中规定同时发送普通文本与 HTML 版本的邮件消息一样。这个功能使用的是 W3C 开发的基本 XHTML 格式（<a href="http://www.w3.org/TR/xhtml-basic/">http://www.w3.org/TR/xhtml-basic/</a>），关于 Jabber 在消息中的 XHTML 执行细节，请看 Jabber 消息的暂定格式规范（<a href="http://docs.jabber.org/draft-proto/html/xhtml.html">http://docs.jabber.org/draft-proto/html/xhtml.html</a>）。所有 XHTML 的根元素都必须是 <code>&lt;html xmlns=”http://www.w3.org/1999/xhmtl”&gt;&lt;/html&gt;</code>。这个根元素中，支持任何一个基本 XHTML 格式中定义的元素，但不是每一个元素可以通过即时消息的上下文来进行理解。</p>

<h4>3.3.4. &lt;subject/></h4>

<p>这是一个可选元素，包含消息的标题。</p>

<h4>3.3.5. &lt;thread/></h4>

<p>当一个 Jabber 客户端发送一个 <code>chat</code> 类型的消息，将生成唯一的线程 ID（通常是由发送者的 <code>Jabber ID</code> 和当前时间生成的一个<code>hash</code>）。消息发送者和接收者在聊天中后续的消息都包含一个 <code>&lt;thread/&gt;</code> 子元素，这个子元素包含原始线程 ID。这使得消息发送者和接收者对回复进行认证并创建一个对话线程。下面的是例子：</p>

<pre><code>&lt;message
from="juliet@capulet.com/balcony"
to="romeo@montague.net/orchard"
type="chat"&gt;
&lt;thread&gt;AAC96FEFDE226C2C04BE8F2E19A2151B&lt;/thread&gt;
&lt;body&gt;Art thou not Romeo and a Montague?&lt;/body&gt;
&lt;/message&gt;
&lt;message
from="romeo@montague.net/orchard"
to="juliet@capulet.com/balcony"
type="chat"&gt;
&lt;thread&gt;AAC96FEFDE226C2C04BE8F2E19A2151B&lt;/thread&gt;
&lt;body&gt;Neither, fair saint, if either thee dislike.&lt;/body&gt;
&lt;/message&gt;
</code></pre>

<h4>3.3.6. &lt;x/></h4>

<p><code>&lt;x/&gt;</code> 元素作为一个扩展机制来使用，或发送从服务器发送命令给客户端，或从一个客户端发送命令到另一个客户端。每次用到这个元素时，必须指明相关的 XML 名字空间。单一消息可以包含多个 <code>&lt;x/&gt;</code> 子元素实例。下列已定义的名字空间可以被 <code>&lt;x/&gt;</code> 子元素使用：</p>

<pre><code>jabber:x:autoupdate
jabber:x:delay
jabber:x:encrypted
jabber:x:oob
jabber:x:roster
</code></pre>

<p>这些名字空间在下面的 Jabber 名字空间中被更完整地描述。</p>

<p>下面是一个使用 <code>jabber:x:delay</code> 名字空间在加入的群组聊天室的显示上下文的例子：</p>

<pre><code>&lt;message
type=’groupchat’
from=’cauldron@conference.witches.org’&gt;
&lt;body&gt;Thrice the brinded cat hath mew’d.&lt;/body&gt;
&lt;x xmlns=’jabber:x:delay’
stamp=’10541031T21:43:40’&gt;Cached In GC History&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h2>4. &lt;presence/>元素</h2>

<p><code>&lt;presence/&gt;</code> 元素提供关于一个 Jabber 实体的可用性信息。任何一个通过一个 <code>Jabber ID</code> 确认的实体可以与另一个实体进行在线状态信息的通信，这种通信大多以订阅在线状态信息的方式进行。</p>

<p>所有实体表现出的在线状态不是“可用”就是“不可用”。“可用”状态表示发送者可以立即收到消息。“不可用”状态表示发送者不能在当前时间收到任何数据。默认情况下，所有 <code>&lt;presence/&gt;</code> 元素除非包含 <code>type=”unavailable”</code> 属性外，都表示“可用”。“可用”的更多特殊形势通过 <code>&lt;status/&gt;和&lt;show/&gt;</code> 子元素进行指定。</p>

<h3>4.1. &ldquo;type"属性</h3>

<p><code>&lt;presence/&gt;</code>的 <code>type</code> 属性根据不同目的使用。除了提示其它用户本用户的可用性状态的“普通”用法外，还包括订阅、取消订阅、以及探测在线状态信息。下面是<code>type</code>属性的可用值：</p>

<h4>4.1.1. type=&ldquo;available&rdquo;</h4>

<p>如果没有包含任何 <code>type</code> 属性，在线状态包将被设为 <code>type=”available”</code>，用来提供用户在线时的信息。一个 <code>type=”available”</code> 的在线状态包通常包含一个<code>&lt;show/&gt;</code> 元素以详细说明 Jabber 实体的可用类型，以及一个 <code>&lt;status/&gt;</code> 元素，该元素包含人能看懂的关于该可用类型的描述。在线状态包还可以包含一个<code>&lt;priority/&gt;</code> 元素，来指明该连接的 <code>Jabber ID</code> 的优先级。</p>

<p>例子：</p>

<pre><code>&lt;presence
from="juliet@capulet.com/balcony"
to="romeo@montague.net/orchard"/&gt;
&lt;show&gt;away&lt;/show&gt;
&lt;status&gt;Stay but a little, I will come again.&lt;/status&gt;
&lt;/presence&gt;
</code></pre>

<p><code>&lt;show/&gt;</code> 元素的可用值为：</p>

<ul>
<li>away――Jabber 用户或实体在线，但不能马上联系上</li>
<li>chat――Jabber N用户或实体在线并有兴趣聊天</li>
<li>dnd――Jabber 用户或实体在线，但不想被打扰（“dnd”表示“do not disturb”）</li>
<li>xa――Jabber 用户或实体在线，但已经离开很长时间了（“xa”表示“extended away”）</li>
</ul>


<p><code>&lt;status/&gt;</code> 可以包含任意特性数据，这些数据通常包含对于用户状态的描述，如，“开会中”是<code>away</code>的一个表现值，或者“忙于编码”可以是<code>dnd</code> 的一个表现。</p>

<h4>4.1.2. type=&ldquo;error&rdquo;</h4>

<p>当一个在线状态包发送给一个不存在的 JID 时，或在发送在线状态请求时发生一个错误时，服务器都将返回一个 <code>type=”error”</code> 的在线状态包。
下面是一个例子（注意域名的类型）：</p>

<pre><code>&lt;presence
       type="subscribe"
to="romeo@montague.nett"/&gt;
</code></pre>

<p>回复的例子：</p>

<pre><code>    &lt;presence
       from="romeo@montague.nett"
    to="juliet@capulet.com/balcony"
    type="error"&gt;
    &lt;error code=’504’&gt;Remote server timeout. Unable to deliver
    packet.&lt;/error&gt;
    &lt;/presence&gt;
</code></pre>

<h4>4.1.3. type=&ldquo;probe&rdquo;</h4>

<p> 向一个特定实体（实体不能发送在线状态消息给自己）发出在线状态信息请求。服务器而非客户端，进行一个探测请求。实际上，虽然 Jabber 客户端也可以发送一个探测一个指定 Jabber 用户是否在线的请求，但通常都是服务器端发出探测请求。注意，只有在发起请求的用户在请求所对应的用户的花名册上，并且拥有 <code>from</code> 或 <code>both</code> 订阅类型时，服务器才会发出探测请求。在下面的例子中，我们将看到我们的英雄 Romeo 向 Juliet 发出一个探测请求，Juliet 所在服务器回复一个“状态报告包”（包含 <code>jabber:x:delay</code> 名字空间中指明的上次在线状态更新的时间戳）</p>

<p>探测请求的例子：</p>

<pre><code>&lt;presence
from="romeo@montague.net"
to="juliet@capulet.com"
type="probe"/&gt;
</code></pre>

<p>回复探测请求的例子：</p>

<pre><code>&lt;presence
from="juliet@capulet.com/."
to="romeo@montague.net"&gt;
&lt;status&gt;Stay but a little, I will come again.&lt;/status&gt;
&lt;show&gt;away&lt;/show&gt;
     &lt;x
xmlns="jabber:x:delay"
from="juliet@capulet.com/."
stamp="15310309T23:47:15"/&gt;
&lt;/presence&gt;
</code></pre>

<h4>4.1.4. type=&ldquo;subscribe&rdquo;</h4>

<p>发送一个请求，这个请求是接收者在其在线状态改变时，自动发送在线状态信息给发送者。</p>

<p>例子：</p>

<pre><code>&lt;presence
from="romeo@montague.net"
to="juliet@capulet.com"
type="subscribe"/&gt;
</code></pre>

<h4>4.1.5. type=&ldquo;subscribed&rdquo;</h4>

<p>发送一个消息，表明发送者接受了接受者对其再现状态订阅的请求。从现在起，当发送者的在线状态信息改变时，服务器将会把状态信息发送给接收者。</p>

<p>例子：</p>

<pre><code>&lt;presence
from="juliet@capulet.com"
to="romeo@montague.net"
type="subscribed"/&gt;
</code></pre>

<h4>4.1.6. type=&ldquo;unavailable&rdquo;</h4>

<p>例子：</p>

<pre><code>&lt;presence
from="juliet@capulet.com"
to="romeo@montague.net"
type="unavailable"&gt;
&lt;status&gt;Disconnnected&lt;/status&gt;
&lt;/presence&gt;
</code></pre>

<h4>4.1.7. type=&ldquo;unsubscribe&rdquo;</h4>

<p>发送一个请求，表明接收者停止发送在线状态信息给发送者。</p>

<p>例子：</p>

<pre><code>&lt;presence
from="juliet@capulet.com"
to="romeo@montague.net"
type="unsubscribe"/&gt;
</code></pre>

<h4>4.1.8. type=&ldquo;unsubscribed&rdquo;</h4>

<p>这种类型的在线状态包有两个用途：</p>

<ol>
<li>发送一个表明发送者接受接收者关于不订阅其在线状态信息的请求的通知。服务器将不再发送发送者的在线状态信息给接收者。</li>
<li>拒绝一个订阅请求。服务器将不再发送发送者的在线状态信息给试图订阅其在线状态信息的用户。</li>
</ol>


<p>例子：</p>

<pre><code>&lt;presence
from="romeo@montague.net"
to="juliet@capulet.com"
type="unsubscribed"/&gt;
</code></pre>

<h3>4.2. 其它&lt;presence/>属性</h3>

<p> 除了设置<code>type</code>属性，还可以通过下列属性修改 <code>&lt;presence/&gt;</code> 元素：</p>

<h4>4.2.1. &ldquo;from"属性</h4>

<p>标识在线状态包的发送者。一般 <code>Jabber ID</code> 在 <code>from</code> 属性中必须写成 <code>user@host/resource</code> 的格式。从 XML 的观点来说，这个属性是所有 <code>&lt;presence/&gt;</code> 元素所必须的，而在实际应用中，都是服务器对该属性进行添加和修改（防止一些欺骗的手段），因此客户端开发者不需要考虑它。</p>

<p>例子：</p>

<pre><code>&lt;presence from="juliet@capulet.com/balcony"/&gt;
</code></pre>

<h4>4.2.2. &ldquo;id"属性</h4>

<p>为在线状态请求包配置唯一的验证符。<code>id</code> 属性由 Jabber 客户端或客户库（如 Gabber 或J abberCOM ）生成，客户端用其为在线状态包的轨迹进行验证。<code>id</code> 属性是可选的，并且不能用于系统其它任何地方。</p>

<p>例子：</p>

<pre><code>&lt;presence to="romeo@montague.net/orchard" id="JCOM_86"/&gt;
</code></pre>

<h4>4.2.3. &ldquo;to"属性</h4>

<p>标识在线状态包的接收者。一般 <code>Jabber ID</code> 在 <code>to</code> 属性中都是 <code>user@host/resource</code> 的格式，<code>user@host</code> 的格式也是可以的，但当接收者在线时，它将转化为 <code>user@host/resource</code>。在 Jabber 的一般用法中，Jabber 客户端向服务器发出在线状态包，服务器将这些在线状态包发送到该用户花名册上所有的用户。当一个 Jabber 客户端发送的 <code>&lt;presence/&gt;</code> 元素中不含<code>to</code>属性时，服务器将将其转化为在线状态包发送给指定的 Jabber 实体。下面的例子将演示这一过程。</p>

<p>发送给服务器的在线状态的例子：</p>

<pre><code>&lt;presence&gt;
&lt;status&gt;Stay but a little, I will come again.&lt;/status&gt;
&lt;show&gt;away&lt;/show&gt;
&lt;/presence&gt;
</code></pre>

<p>服务器发给指定用户的在线状态例子：</p>

<pre><code>&lt;presence
to="romeo@montague.net/orchard"
from="juliet@capulet.com/balcony"&gt;
&lt;status&gt;Stay but a little, I will come again.&lt;/status&gt;
&lt;show&gt;away&lt;/show&gt;
&lt;/presence&gt;
</code></pre>

<h3>4.3. &lt;presence/>的子元素</h3>

<p>下面的元素用于 <code>&lt;presence/&gt;</code> 协议。</p>

<h4>4.3.1. &lt;priority/></h4>

<p>在 Jabber 中，根据 Jabber 知道的设备数或位置数，一个用户可以建立相同数量的连接。用户可以给每一个资源赋予一个数字优先级（通过对指派给该资源的 Jabber 客户端进行设置），这个优先级与 <code>&lt;presence/&gt;</code> 元素的子元素 <code>&lt;priority/&gt;</code> 方法进行通信。</p>

<p>当在线状态包发送到服务器后，服务器有能力决定哪一个连接资源需要指派一个单一的 <code>Jabber ID</code> ，该资源将收到发往该 <code>Jabber ID</code> 的消息，这是因为数字最高的资源是默认或第一资源。如果最高优先级的资源不可用，消息和其它J abber 通信将发送给次高优先级的资源（当其它资源都不可用时，一个没有从默认数到0的优先级的客户端，也可以成为第一资源）</p>

<p>举例来说，Julie 可以通过两个资源：the balcony 和 the chamber 连接她的帐号 <code>juliet@capulet.com</code>。如果 <code>balcony</code> 资源的优先级被设置为“2”，而 <code>chamber</code> 资源的优先级被设为“1”，而且两个资源都可以连接，消息将发送到 <code>juliet@capulet.com/balcony</code>，而不是 <code>juliet@capulet.com/chamber</code>。</p>

<h4>4.3.2. &lt;show/></h4>

<p>可选的 <code>&lt;show/&gt;</code> 元素告诉 Jabber 客户端如何显示一个用户的在线状态。<code>&lt;show&gt;</code> 标签是一个典型的 <code>&lt;status&gt;</code> 标签的伴随标签，<code>&lt;status&gt;</code> 标签包含更多在线状态改变理由的描述信息。如果<code>&lt;show/&gt;</code>元素不在 <code>&lt;presence/&gt;</code> 元素中，Jabber 接收客户端将指明该用户处于“普通”状态。下面是四个可选项：</p>

<pre><code>标签                   含义

&lt;show&gt;chat&lt;/show&gt;    该客户可以马上联系上
&lt;show&gt;away&lt;/show&gt;    该客户在线，但刚刚离开（如吃午饭，开会）
&lt;show&gt;xa&lt;/show&gt;      该客户在线，但已经处于非活动状态很长时间了。
&lt;show&gt;dnd&lt;show&gt;      该用户处于谢绝打扰的模式
</code></pre>

<h4>4.3.3. &lt;status/></h4>

<p><code>&lt;status/&gt;</code> 元素包含更多关于用户在线状态的描述。大多数 Jabber 客户端都包含一些 <code>&lt;status/&gt;</code> 元素的默认设置；另外，它们还允许我们提供富有个性的描述如“我在吃午饭”或者“钓鱼中”。</p>

<h4>4.3.4. &lt;x/></h4>

<p><code>&lt;x/&gt;</code> 元素作为一个扩展机制来使用，或发送从服务器发送命令给客户端，或从一个客户端发送命令到另一个客户端。每次用到这个元素时，必须指明相关的 XML 名字空间。单一消息可以包含多个 <code>&lt;x/&gt;</code> 子元素实例。下列已定义的名字空间可以被<x/>子元素使用：</p>

<pre><code>jabber:x:autoupdate       
jabber:x:delay
jabber:x:encrypted
jabber:x:oob
jabber:x:roster
</code></pre>

<p>这些名字空间在下面的 Jabber 名字空间中被更完整地描述。</p>

<h2>5. &lt;iq/>元素</h2>

<p>信息/查询(IQ)在 Jabber 中在两个实体间构建一个根本的会话，并且允许实体间来回传送 XML 格式的请求和响应。信息/查询主要的用处是取得或设置公共的用户信息，比如名字，电子邮件，地址等等。但它的灵活设计使得任何种类的会话都可以发生。任何通过一个 Jabber ID 标识的实体都能通过一个 IQ 与其它实体进行会话。</p>

<h3>5.1. &ldquo;type"属性</h3>

<p><code>&lt;iq/&gt;</code> 元素的<code>type</code>属性用于决定信息/查询是请求还是响应。下面是<code>type</code>属性的可用值：</p>

<h4>5.1.1. type=&ldquo;error&rdquo;</h4>

<p>表示查询失败。实际错误在<code>&lt;iq/&gt;</code>元素的 <code>&lt;error/&gt;</code> 子元素中描述。</p>

<p> 例子：</p>

<pre><code>&lt;iq type="error" to="romeo@montague.net"&gt;
&lt;error code="403"&gt;Forbidden&lt;/error&gt;
&lt;/iq&gt;
</code></pre>

<h4>5.1.2. type=&ldquo;get&rdquo;</h4>

<p>找回指派给一个查询名字空间的信息。如果没有设置属性，默认情况，这个属性包含在查询中。一个 <code>type=”get”</code> 的 <code>&lt;iq/&gt;</code> 元素由一个子元素构成，这个子元素通常是 <code>&lt;query&gt;</code>，但也可以是 <code>&lt;vcard/&gt;</code> 或另一个已有的子元素。不过，指定的子元素必须左空，以便接收一个用户所需提供的信息的空间的清单。一个成功的 get 查询的结果 <code>type=”result”</code> 的 <code>&lt;iq/&gt;</code> 元素，是元素嵌套在包含了所需信息的指定子元素（如 <code>&lt;query&gt;</code> 或 <code>&lt;vcard/&gt;</code> ）。</p>

<p>例子：</p>

<pre><code>&lt;iq type="get"&gt;
    &lt;vCard xmlns="vcard-temp"/&gt;
&lt;/iq&gt;
</code></pre>

<h4>5.1.3. type=&ldquo;result&rdquo;</h4>

<p>表示 <code>&lt;iq/&gt;</code> 包是一个 <code>type=”get”</code> 或 <code>type=”set”</code> 的 <code>&lt;iq/&gt;</code> 查询的成功响应。这个成功查询的结果是一个 <code>type=”result”</code> 的 <code>&lt;iq/&gt;</code> 元素，该元素嵌套在一个包含所查询的信息的子元素中（如<code>&lt;query&gt;</code>、<code>&lt;vcard/&gt;</code>）。一个成功的查询或获取查询结果的返回是一个空的 <code>type=”result”</code> 的 <code>&lt;iq/&gt;</code> 元素。一个不成功的返回是一个 <code>type=”error”</code> 的 <code>&lt;iq/&gt;</code> 元素。<code>&lt;iq type=”result”/&gt;</code> 通常与 <code>id</code> 属性的获取、设定查询有关。</p>

<p>例子：</p>

<pre><code>&lt;iq type="result"&gt;
&lt;vCard version="3.0" xmlns="vcard-temp"&gt;
vCard data goes here
&lt;/vCard&gt;
&lt;/iq&gt;
</code></pre>

<h4>5.1.4. type=”set”</h4>

<p>表示 <code>&lt;iq/&gt;</code> 包是对设值或更改现有数据值。一个 <code>type=”set”</code> 的 <code>&lt;iq/&gt;</code> 元素总是包含一个指定的子元素，通常是 <code>&lt;query&gt;</code> ，也可以是 <code>&lt;vcard/&gt;</code> 或者其它可以接受的子元素。一个设置命令查询的成功返回是一个空的 <code>type=”result”</code> 的 <code>&lt;iq/&gt;</code> 元素。</p>

<p>例子：</p>

<pre><code>&lt;iq type="set"&gt;
&lt;vCard version="3.0"&gt;
vCard data goes here
&lt;/vCard&gt;
&lt;/iq&gt;
</code></pre>

<h3>5.2. 其它&lt;iq/>属性</h3>

<p>除了<code>type</code>属性外，IQ 元素还可以通过下面的属性进行修改。</p>

<h4>5.2.1. &ldquo;from"属性</h4>

<p>表示 <code>iq</code> 包的发送者。从 XML 观点来说，这个属性是所有 <code>&lt;iq/&gt;</code> 元素所必须的，实际应用中这个属性是服务器来增加和修改的（为防止某些欺骗），因此客户端的开发人员不需要过多关注这个属性。</p>

<p>例子：</p>

<pre><code>&lt;iq from="romeo@montague.net"/&gt;
</code></pre>

<h4>5.2.2. &ldquo;id"属性</h4>

<p>一个 <code>iq</code> 包只有唯一的标识。Jabber 客户端或客户库生成 <code>id</code> 属性，客户端通过它来标识 <code>&lt;iq/&gt;</code> 包，以完成对 <code>&lt;iq/&gt;</code> 包的跟踪（如：一个<code>type=”result”</code> 对应一个<code>type=”get”</code> 或<code>type=”set”</code> ）。<code>id</code> 属性是可选的，并且不能用于系统的其它地方。</p>

<p>例子：</p>

<pre><code>&lt;iq type="get" from="juliet@capulet.com/balcony" id="JCOM_87"/&gt;
&lt;iq type="result" to="juliet@capulet.com/balcony" id="JCOM_87"/&gt;
</code></pre>

<h4>5.2.3. &ldquo;to"属性</h4>

<p>表示 <code>iq</code> 包的接收者。在 Jabber 客户端，对应 <code>to</code> 属性的 Jabber ID 的格式为 <code>user@host/resource</code>。<code>user@host</code> 也是可以的，如果用户在线，<code>user@host</code> 将被置换成 <code>user@host/resource</code>，如果用户不在线，<code>user@host</code> 将被直接指向一个离线模块（对于类似服务器端网关这种非用户实体，情况又有所不同，因为它们不拥有资源，并且只是简单通过 Jabber ID 的一个<code>server</code>端口进行标识。Jud.jabber.org——Jabber 用户目录就是这样一个例子）。如果<code>&lt;iq/&gt;</code>包没有 <code>&lt;to&gt;</code> 属性，服务器将对该包进行处理。</p>

<p>例子：
    <iq to="juliet@capulet.com/balcony"></p>

<h3>5.3 &lt;iq/>的子元素</h3>

<p>下面介绍 <code>&lt;iq/&gt;</code>元素的子元素。</p>

<h4>5.3.1. &lt;error/></h4>

<p>当 <code>iq</code> 的属性类型被设置为<code>error</code> 时，将用到本属性。错误代码根据一个含有错误数的<code>type</code>属性进行定义，<code>&lt;error/&gt;</code>  元素包含该错误的文本描述。比如，下面就是一个坏请求：</p>

<pre><code>&lt;error code="400"&gt;Bad Request&lt;/error&gt;
</code></pre>

<p>在附录中，列有错误编码及其对应的错误描述。</p>

<h4>5.3.2. &lt;key/></h4>

<p><code>&lt;key/&gt;</code> 元素为客户端－服务器之间交互提供一层安全保护。它被用户 <code>jabber:iq:register</code> 和 <code>jabber:iq:search</code> 名字空间中。</p>

<p>当一个客户端发起一个与服务其之间的交互时，服务器将发送一个包含一个唯一值的 <code>&lt;key&gt;</code> 给客户端。客户端在返回 <code>&lt;iq type=”set”/&gt;</code> 的消息中，包含上诉唯一值到 <code>&lt;key/&gt;</code> 子元素中。这样，服务器就认为该客户端时接收到原来密码的同一实体。</p>

<h4>5.3.3. &lt;query/></h4>

<p><code>&lt;iq/&gt;</code> 元素中的 <code>&lt;query/&gt;</code> 子元素定义所执行的查询的类型。特殊情况下，查询可以拥有一个特殊的名字空间，这个名字空间是一个通过 <code>xmlns</code> 属性定义的<code>&lt;query/&gt;</code> 子元素。一个 <code>&lt;iq/&gt;</code> 元素中只能有一个 <code>&lt;query/&gt;</code> 子元素。</p>

<p>下面的例子是当我通过我的 Linux 机器上的 Grabber 客户端登陆到服务器上，将出现的 XML。</p>

<pre><code>&lt;iq type="set"&gt;
&lt;query xmlns="jabber:iq:auth"&gt;
&lt;username&gt;stpeter&lt;/username&gt;
&lt;resource&gt;Gabber&lt;/resource&gt;
&lt;digest&gt;f1e881517e9917bb815fed112d81d32b4e4b3aed&lt;/digest&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>就象你看到的那样，认证查询通过客户端认证名字空间（jabber:iq:auth）向服务器发送认证信息。一般，Jabber 核心协议保留 <code>jabber:iq:*这样的名字空间。而开发者可以通过增加jabber:iq:*</code> 名字空间对 Jabber 核心进行扩展。这些将在下面的名字空间中进行更完整的描述。</p>

<p>一个空 <code>&lt;query/&gt;</code> 子元素可以与 <code>&lt;iq type=”get”&gt;</code> 元素一起发送，这样可以找回与 <code>&lt;query/&gt;</code> 子元素中指定的名字空间相关的一个 Jabber 实体的信息。比如，找回一个客户端的花名册（“联系人名单”），下面的 XML 可以被发送：</p>

<pre><code>&lt;iq to="juliet@capulet.com/balcony" type="get"&gt;
&lt;query xmlns="jabber:iq:roster"/&gt;
&lt;/iq&gt;
</code></pre>

<h2>6. 名字空间</h2>

<p>现面是 Jabber 中的标准名字空间：</p>

<pre><code>jabber:iq:agent——代理工具
jabber:iq:agents——有效的代理组
jabber:iq:auth——简单用户认证
jabber:iq:autoupdate——版本更新申请
jabber:iq:browse——Jabber浏览
jabber:iq:conference——一般会议
jabber:iq:gateway——用户地址网关
jabber:iq:last——上次使用时间
jabber:iq:oob——绑定数据输出
jabber:iq:private——私有数据存储
jabber:iq:register——注册请求
jabber:iq:roster——花名册（联系人名单）管理
jabber:iq:search——用户数据库查询
jabber:iq:time——客户端时间
jabber:iq:version——客户端版本
jabber:x:autoupdate——版本通知申请
jabber:x:conference——会议邀请
jabber:x:delay——显示的对象
jabber:x:encrypted——加密的消息
jabber:x:envelope——消息封套
jabber:x:event——消息事件
jabber:x:expire——消息终止
jabber:x:oob——绑定数据（文件传输）输出
jabber:x:roster——内部的花名册条目
jabber:x:signed——标记的在线状态
vcard-temp——临时的vCard
</code></pre>

<p>下面将详细介绍这些名字空间的细节。</p>

<h3>6.1. jabber:iq:agent——代理工具</h3>

<p>代理工具名字空间包含一个代理的所有工具。<code>jabber:iq:angents</code> 查询通常用于注册到一个指定的服务、代理、传输器。
它也可能检验一个指定代理的所有工具细节。比如，一个客户端可以决定一个开放的注册是否可以进行。</p>

<p>例子：</p>

<pre><code>&lt;iq id="wjAgent" type="result" from="Jabber.org"&gt;
&lt;query xmlns="jabber:iq:agent"&gt;
&lt;agent jid="aim.jabber.org"&gt;
&lt;name&gt;AIM Transport&lt;/name&gt;
&lt;description&gt;This is the AIM Transport&lt;/description&gt;
&lt;transport&gt;AIM/AOL ScreenName&lt;/transport&gt;
&lt;service&gt;aim&lt;/service&gt;
&lt;register/&gt;
&lt;/agent&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.2. jabber:iq:angents——可用的代理列表</h3>

<p>可用代理列表名字空间包含一组实体，这些实体拥有一些特殊工具，并能够为另一个实体提供服务。大多数情况下，可用代理列表是用来显示一台服务器上的可用传输器列表。</p>

<p>注意：这个名字空间被 <code>jabber:iq:browse</code> 的支持者所反对（？？）。</p>

<p>例子：</p>

<pre><code>&lt;iq id="wjAgents" type="result" from="jabber.org"&gt;
&lt;query xmlns="jabber:iq:agents"&gt;
&lt;agent jid="users.jabber.org"&gt;
&lt;name&gt;User Directory&lt;/name&gt;
&lt;description&gt;
You may register and create a public searchable
profile, and search for other registered Jabber
users.
&lt;/description&gt;
&lt;service&gt;jud&lt;/service&gt;
&lt;register/&gt;
&lt;search/&gt;
&lt;/agent&gt;
&lt;agent jid="aim.jabber.org"&gt;
&lt;name&gt;AIM Transport&lt;/name&gt;
&lt;description&gt;This is the AIM Transport&lt;/description&gt;
&lt;transport&gt;AIM/AOL ScreenName&lt;/transport&gt;
&lt;service&gt;aim&lt;/service&gt;
&lt;register/&gt;
&lt;/agent&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.3. jabber:iq:auth——简单客户端认证</h3>

<p>简单客户认证名字空间是对客户端进行认证的一个简单机制，它为客户端到服务器之间的连接创建一个资源。
认证成功返回一个 <code>type=”result”</code> 的 IQ 响应。不成功，就返回一个错误IQ元素。</p>

<p>如果没有发送名字空间或密码，如果服务器允许，服务器将创建一个匿名资源。</p>

<p>例子：</p>

<pre><code>&lt;iq type="set" id="JCOM_0"&gt;
&lt;query xmlns="jabber:iq:auth"&gt;
&lt;username&gt;juliet&lt;/username&gt;
&lt;password&gt;secret&lt;/password&gt;
&lt;resource&gt;balcony&lt;/resource&gt;
&lt;/query&gt;
&lt;/iq&gt;
&lt;iq type="set" id="JCOM_0"&gt;
&lt;query xmlns="jabber:iq:auth"&gt;
&lt;username&gt;juliet&lt;/username&gt;
&lt;digest&gt;a5e052c48c455bf21d937ccf17225916d9486b09&lt;/digest&gt;
&lt;resource&gt;balcony&lt;/resource&gt;
&lt;/query&gt;
&lt;/iq&gt;
&lt;iq type="set" id="JCOM_0"&gt;
&lt;query xmlns="jabber:iq:auth"&gt;
&lt;username&gt;juliet&lt;/username&gt;
&lt;hash499&gt;secret&lt;/hash499&gt;
&lt;resource&gt;balcony&lt;/resource&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.4. jabber:iq:autoupdate——版本更新申请</h3>

<p>版本更新申请名字空间允许客户端对所有可用软件更新进行申请请求。</p>

<p>例子：</p>

<pre><code>&lt;iq type="get" to="jabber.org" id="1"&gt;
&lt;query xmlns="jabber:iq:autoupdate"/&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.5.jabber:iq:browse——Jabber浏览</h3>

<p>Jabber 浏览名字空间的作用是，一是为 Jabber 世界中已有的 Jabber IDs 增加结构的一个途径，一是发现为不同 Jabber 实体提供的服务或应用。一个 Jabber 浏览的基本概念就是一个 <code>jid-type</code>（类似文件的一个模拟类型的概念）。下面是想象中的最高级别的 <code>jid-types</code>，不过随着时间的推移，一些其它的逻辑将被增加进来：</p>

<ul>
<li>应用</li>
<li>会议</li>
<li>标题</li>
<li>关键字</li>
<li>回报</li>
<li>服务</li>
<li>用户</li>
</ul>


<p>上面每一个范畴都有一个子类列表，如用户/客户端，或用户/设备（“客户端”或“设备”只是一个“资源”的概念），会议<code>/irc</code>，服务<code>/icq</code>，标题/库存。一般的，通过使用<code>jabber:iq:browse</code>名字空间你将拥有一个与上述某一<code>jid-type</code>范畴相对应的元素，这个元素通常有一个指定子类型的<code>type</code>属性。</p>

<p><code>Jabber:iq:browse</code>的一个用户就是代替 <code>jabber:iq:agents</code> 名字空间来列出一个服务器上所对应的代理或其它服务。下面是一个浏览服务器的例子：</p>

<p>Jabber 客户端发送：</p>

<pre><code>&lt;iq type="get" to="jabber.org"&gt;
&lt;query xmlns="jabber:iq:browse"/&gt;
&lt;/iq&gt;
</code></pre>

<p>Jabber 服务器返回：</p>

<pre><code>&lt;iq type="result" from="jabber.org"&gt;
&lt;service
type="jabber"
jid="jabber.org"
xmlns="jabber:iq:browse&gt;
&lt;service
type="jud"
jid="users.jabber.org"
name="Jabber User Directory"&gt;
&lt;ns&gt;jabber:iq:register&lt;/ns&gt;
&lt;ns&gt;jabber:iq:search&lt;/ns&gt;
&lt;/service&gt;
&lt;service
type="aim"
jid="aim.jabber.org"
name="AIM Transport"&gt;
&lt;ns&gt;jabber:iq:register&lt;/ns&gt;
&lt;ns&gt;jabber:iq:search&lt;/ns&gt;
&lt;/service&gt;
&lt;conference
type="private"
jid="conference.jabber.org"
name="Private Chatrooms"&gt;
&lt;/service&gt;
&lt;/service&gt;
&lt;/iq&gt;
</code></pre>

<p>在会议中的一个例子：</p>

<pre><code>&lt;iq type="set" to="room@server"&gt;
&lt;conference xmlns="jabber:iq:browse" name="Room Name"&gt;
&lt;user jid="room@server/jidhash" name="nick1"/&gt;
&lt;user jid="room@server/jidhash" name="nick2"/&gt;
&lt;/conference&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.6. jabber:iq:conference——一般会议</h3>

<p>一般会议名字空间提供一个会议室的机制（如群组聊天室），并提供该会议室的入口。这个名字空间与 <code>&lt;/iq&gt;</code> 元素配套使用来获得一个会议室的信息，包括要求加入这个会议室的请求信息，以及为这个会议室设置信息（通常是为了加入这个房间）。一个普通进入房间的请求将和下面的类似：</p>

<h4>1.想要加入的房间提交一个type=”get”的请求。这个XML将是下面的形式：</h4>

<pre><code>&lt;iq type="get" to="room@server"&gt;
&lt;query xmlns="jabber:iq:conference"/&gt;
&lt;/iq&gt;
</code></pre>

<h4>2.接受来自要加入的房间的type=”result”的iq响应，其中有进入房间所需要的参数。这个XML将是下面的形式：</h4>

<pre><code>&lt;iq type="result" from="room@server"&gt;
&lt;query xmlns="jabber:iq:conference"&gt;
&lt;nick/&gt;
&lt;secret/&gt;
&lt;privacy/&gt;
&lt;name&gt;Room Name&lt;/name&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>这里所有的请求元素的子元素都是可选的。昵称(nickname)元素表示进入房间需要一个昵称。密钥(secret)元素表示进入房间的用户需要提供一个密码。独处(privacy)元素表示如果用户在一个 <code>type=”set”</code>（下面可以看到例子）的iq包中提供这样的元素，会议服务器将隐藏用户的真实 Jabbere ID 。名字（name）元素是房间的名字（用 <code>jabber：iq:browse</code> 浏览房间时可以看到同样的房间名）。</p>

<h4>3.发送当前状态给要加入的房间。XML如下：</h4>

<pre><code>&lt;presence to="room@server"/&gt;
</code></pre>

<h4>4.想要加入的房间提交一个type=”set”的iq包以及进入所需信息。XML如下：</h4>

<pre><code>&lt;iq type="set" to="room@server"&gt;
&lt;query xmlns="jabber:iq:conference"&gt;
&lt;nick&gt;mynick&lt;/nick&gt;
&lt;nick&gt;mysecondnick&lt;/nick&gt;
&lt;secret&gt;thesecret&lt;/secret&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>注意在用户第一个选择被接受时，用户可以提交多个昵称。如果用户没有提供昵称，服务器将指派一个昵称给用户。</p>

<h4>5.收到你加入的房间的通知，这个iq以下面的格式返回：</h4>

<pre><code>&lt;iq type="result" from="room@server"&gt;
&lt;query xmlns="jabber:iq:conference"&gt;
&lt;id&gt;room@server/uniqueidnumber&lt;/id&gt;
&lt;nick&gt;mynick&lt;/nick&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>这个唯一的 ID 号是用户 Jabber ID 的一个哈希。</p>

<h3>6.7. jabber:iq:gateway——用户地址网关</h3>

<p>一般通过一个网关或传输器（比如AIM传输器）来实现与非Jabber网络用户的通信，每一个非 Jabber 网络都可能拥有唯一的用户地址，这个地址可能和 Jabber IDs 并不统一。用户地址网关就是解决这个问题的，它使得 Jabber 客户端向非 Jabber 网络用户发出订阅时给出正确 Jabber IDs 变得很容易。这些通过对用户进行提示和会话，引导用户提供创建一个正确 Jabber ID 所需信息来实现。下面将演示这种普通的交互：</p>

<h4>1.客户端向网关发出带有jabber:iq:gate名字空间查询的iq get：</h4>

<pre><code>&lt;iq type="get" to="aim.jabber.org"&gt;
&lt;query xmlns="jabber:iq:gateway"/&gt;
&lt;/iq&gt;
</code></pre>

<h4>2.服务器返回一个包含请求批准及其描述文本的iq：</h4>

<pre><code>&lt;iq type="result" from="aim.jabber.org"&gt;
&lt;query xmlns="jabber:iq:gateway"&gt;
&lt;desc&gt;
Please enter the AOL Screen Name of the person
you would like to contact.
&lt;/desc&gt;
&lt;prompt&gt;Screen Name&lt;/prompt&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h4>3.客户端向网关发送一个包含指定信息的iq set：</h4>

<pre><code>&lt;iq type="set" to="aim.jabber.org"&gt;
&lt;query xmlns="jabber:iq:gateway"&gt;
&lt;prompt&gt;Joe Cool&lt;/prompt&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h4>4.服务器返回一个包含正确Jabber ID的iq result</h4>

<pre><code>&lt;iq type="result" from="aim.jabber.org"&gt;
&lt;query xmlns="jabber:iq:gateway"&gt;
&lt;jid&gt;JoeCool@aim.jabber.org&lt;/jid&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.8. jabber:iq:last——最后一次在线时间</h3>

<p>最后一次在线时间名字空间提供一个标准的方法，通过这个方法可以查询一个 Jabber 实体一个或多个服务更新时间，或者一个客户最后一次连接（或活动）到一台服务器上的时间。每一次返回的值都是一个秒的数目。进行查询的实体可以通过下面的法则解释获取的信息：</p>

<ul>
<li>user@server/resource——用户最后一次活动的时间</li>
<li>user@server——用户最后一次连接的时间</li>
<li>server——服务器最后一次启动的时间</li>
</ul>


<p>例子（服务器）：</p>

<pre><code>&lt;iq type="get" to="jabber.org"&gt;
&lt;query xmlns="jabber:iq:last"/&gt;
&lt;/iq&gt;

&lt;iq type="result" to="stpeter@jabber.org/Gabber" from="jabber.org"&gt;
&lt;query xmlns="jabber:iq:last" seconds="124933"/&gt;
&lt;/iq&gt;
</code></pre>

<p>例子（客户端）：</p>

<pre><code>&lt;iq type="get" to="jer@jabber.org"&gt;
&lt;query xmlns="jabber:iq:last"/&gt;
&lt;/iq&gt;

&lt;iq type="result" to=stpeter@jabber.org/Gabber from="jer@jabber.org"&gt;
&lt;query xmlns="jabber:iq:last" seconds="5024"&gt;
Disconnected
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.9. jabber:iq:oob——绑定数据输出</h3>

<p>绑定数据输出名字空间为客户端－客户端的文件传输提供一个标准方法，通过服务器的传输/代理的传输器实现一个特殊的名字空间：</p>

<p>例子：</p>

<pre><code>&lt;iq type="set" to="horatio@denmark.com" id="file_1"&gt;
&lt;query xmlns="jabber:iq:oob"&gt;
&lt;url&gt;http://denmark.com/act4/letter-1.html&lt;/url&gt;
&lt;desc&gt;There’s a letter for you sir.&lt;/desc&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.10. jabber:iq:private——私有数据存储</h3>

<p>私有数据存储名字空间是 Jabber 服务器上存储私有数据的一个机制。存储的数据可以是任何合法的 XML 数据。在服务端存放客户端的当前状态信息是这个名字空间的典型用法。</p>

<p>例子1（客户端存储私有数据）：</p>

<pre><code>&lt;iq type="set" id="1001"&gt;
&lt;query xmlns="jabber:iq:private"&gt;
&lt;winjab xmlns="winjab:prefs"&gt;
&lt;defaultnick&gt;Hamlet&lt;/defaultnick&gt;
&lt;/winjab&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>例子2（客户端找回私有数据）：</p>

<pre><code>&lt;iq type="get" id="1002"&gt;
&lt;query xmlns="jabber:iq:private"&gt;
&lt;winjab xmlns="winjab:prefs"/&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>另外，对于私有数据存储，1.4版服务器支持服务器上所有有效名字空间（以“jabber”开头的名字空间保留，为 Jabber 系统进行调用）的 XML 数据。这个数据存在向服务器端发送<code>type=”set”</code>的<code>iq</code>包的用户的花名册中。</p>

<p>例子1（客户端保存公有数据）：</p>

<pre><code>&lt;iq type="set" id="1003"&gt;
&lt;query xmlns="stpeter:public:favorites"&gt;
&lt;fav_things&gt;
&lt;food&gt;Thai&lt;/food&gt;
&lt;color&gt;blue&lt;/color&gt;
&lt;composer&gt;Bach&lt;/composer&gt;
&lt;/fav_things&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>例子2（客户端找回公有数据）：</p>

<pre><code>&lt;iq type="get" id="1004"&gt;
&lt;query xmlns="stpeter:public:favorites"&gt;
&lt;fav_things/&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.11. jabber:iq:register——注册请求</h3>

<p>注册请求名字空间对一个或多个服务进行注册。它也被用来更新或删除一个注册。</p>

<p>例子：</p>

<pre><code>&lt;query xmlns="jabber:iq:register"&gt;
&lt;instructions&gt;
Some instructions to be displayed when the
user is filling out the form.
&lt;/instructions&gt;
&lt;username/&gt;
&lt;password/&gt;
&lt;email/&gt;
&lt;date/&gt;
&lt;key/&gt;
&lt;/query&gt;
</code></pre>

<h3>6.12. jabber:iq:roster——联系人名单管理</h3>

<p>联系人名单管理名字空间是客户端用来管理他们的花名册的，该花名册保存在服务器上，这样用户可以在任何地方得到它。花名册是该帐号上所有订阅信息的命令列表，包括用户昵称和联系列表。当用户从任何一个资源登陆上来，服务器将把花名册发送给用户。
花名册是一个条目的列表。每一个条目元素都有描述它的属性。每一个条目元素都包含它所属组的组元素。下面是描述 <code>&lt;item/&gt;</code> 元素的属性：</p>

<ul>
<li>“jid”是条目的 Jabber ID</li>
<li>“subscription” 所有和本条目相关的订阅所对应的用户的当前状态。它可以是 “none”（不可订阅），“to”（有一个发到该条目的订阅），“from”（从该条目发送一个订阅给我们），“both”（to、from），或者“remove”（从花名册上删除一个条目）。</li>
<li>“ask” 是对这个条目的一个请求的当前状态。Subscribe 表示请求对该条目进行订阅，它的值就是，Unsubscribe 表示取消订阅。</li>
<li>“name” 表示昵称</li>
</ul>


<p>通过使用一个 <code>&lt;iq type=”set”/&gt;</code>，一个 <code>Jabber</code> 客户端可以控制用户的 <code>JabberID</code>，名称属性，群组元素，并且可以在联系人名单上创建或删除联系人。服务器根据客户端对当前状态订阅请求的响应来管理其它所有属性。</p>

<p>订阅请求的例子：</p>

<pre><code>&lt;iq type="set" id="uniquevalue"&gt;
&lt;query xmlns="jabber:iq:roster"&gt;
&lt;item jid="romeo@montague.net"
name="Romeo"
subscription="none"
ask="subscribe"&gt;
&lt;group&gt;friends&lt;/group&gt;
&lt;/item&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>当一个花名册条目在服务器上改变时，服务器将把这个改变推送给一个用户。这个推送是一个普通的从服务器发送到客户端的 <code>&lt;iq type=”set”/&gt;</code> 包。下面是一个例子：</p>

<pre><code>&lt;iq type="set"&gt;
&lt;query xmlns="jabber:iq:roster"&gt;
&lt;item jid="romeo@montague.net" subscription="both"/&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>在上面的例子中，服务器推送给客户端一个花名册，表明该用户对<code>romeo@montague.net</code>的当前状态信息有订阅。一个花名册推送可能发生一个连接的任何时间中，该连接是另一个连接修改资源或服务器（修改订阅属性）的结果。客户端只有使用花名册推送来改变花名册的显示。但不是每次花名册推送都对用户起作用。</p>

<h3>6.13. jabber:iq:search——用户数据库查询</h3>

<p>任何一个代理都可以成为一个查询代理。例如，JUD 查询 Jabber 用户，ICQ 传输器查询 ICQ 用户。</p>

<p>用户发送一个进行可查询域的 Get 请求：</p>

<pre><code>&lt;iq
type="get"
id="1001"
to="users.jabber.org"
from="romeo@montague.net/orchard"&gt;
&lt;query xmlns="jabber:iq:search"/&gt;
&lt;/iq&gt;
</code></pre>

<p>查询代理返回一个可查域：</p>

<pre><code>&lt;iq type="result" id="1001" from="users.jabber.org"&gt;
&lt;query xmlns="jabber:iq:search"&gt;
&lt;instructions&gt;Fill in a field to search for any
matching Jabber User
&lt;/instructions&gt;
&lt;name/&gt;
&lt;first/&gt;
&lt;last/&gt;
&lt;nick/&gt;
&lt;email/&gt;
&lt;key&gt;067941fd96a6a2752a21abcb6d737130dd51dd50&lt;/key&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p> 注意这些域是以提示的形式返回。为了传输的安全还包含一个密钥（下面会看到）。用户现在可以在允许的域内进行标准的查询了。用户发回一个Set请求给代理进行实际查询：</p>

<pre><code>&lt;iq
type="set"
id="1002"
to="users.jabber.org"
from="romeo@montague.net/orchard"&gt;
&lt;query xmlns="jabber:iq:search"&gt;
&lt;last&gt;Capulet&lt;/last&gt;
&lt;key&gt;11b830e604215c3a2a24652c69fd4efa2a7a5746&lt;/key&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>服务器根据查询返回结果：</p>

<pre><code>&lt;iq type="result" id="1002" from="users.jabber.org"&gt;
&lt;query xmlns="jabber:iq:search"&gt;
&lt;item jid="juliet@capulet.com"&gt;
&lt;name&gt;Juliet Capulet&lt;/name&gt;
&lt;first&gt;Juliet&lt;/first&gt;
&lt;last&gt;Capulet&lt;/last&gt;
&lt;nick&gt;juliC&lt;/nick&gt;
&lt;email&gt;&lt;/email&gt;
&lt;/item&gt;
&lt;item jid="sampson@capulet.com&gt;
&lt;name&gt;Sampson Capulet&lt;/name&gt;
&lt;first&gt;Sampson&lt;/first&gt;
&lt;last&gt;Capulet&lt;/last&gt;
&lt;nick&gt;sammy&lt;/nick&gt;
&lt;email&gt;&lt;/email&gt;
&lt;/item&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>注意有两套 items 标记含有指定信息。这是因为通过代理发送返回有两种方法：</p>

<ul>
<li>单一返回标签</li>
<li>多个“pushed”到用户的标签，类似花名册推送，如在一个时间上的一个记录。</li>
</ul>


<p>发送的返回的样式是查询代理的一个工具。比如：</p>

<pre><code>&lt;iq type="set" from="icq.jabber.org" id="1003"&gt;
&lt;query xmlns="jabber:iq:search"&gt;
&lt;item jid="7090245@icq.jabber.org"&gt;
&lt;email&gt;juliet@capulet.com&lt;/email&gt;
&lt;nick&gt;juliC&lt;/nick&gt;
&lt;given&gt;Juliet&lt;/given&gt;
&lt;family&gt;Capulet&lt;/family&gt;
&lt;/item&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<p>多个查询结果通过服务器进行推送。当所有数据发送完毕，服务器将发送下面的返回结果：</p>

<pre><code>&lt;iq type="result" from="icq.jabber.org" id="1003"&gt;
&lt;query xmlns="jabber:iq:search"/&gt;
&lt;/iq&gt;
</code></pre>

<p>客户端接收到多个“sets”，每一个都被记录，最后收到一个表示“数据结尾”的“返回”。在每一个<code>&lt;item&gt;</code>标签中，JID 属性都被强制带上。
例子：</p>

<pre><code>&lt;iq
type="get"
id="1001"
to="users.jabber.org"
from="juliet@capulet.com"&gt;
&lt;query xmlns="jabber:iq:search"/&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.14. jabber:iq:time——客户端时间</h3>

<p>客户端时间名字空间是客户端改变当前时间的一个标准方法。</p>

<p>例子：</p>

<pre><code>&lt;iq type="result" from="stpeter@jabber.org"&gt;
&lt;query xmlns="jabber:iq:time"&gt;
&lt;utc&gt;20010214T18:55:06&lt;/utc&gt;
&lt;display&gt;2/15/00 4:55:06 PM&lt;/display&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.15. jabber:iq:version——客户端版本</h3>

<p>客户端版本名字空间是得到另一个用户的客户端的版本信息的一个标准方法。</p>

<p>例子：</p>

<pre><code>&lt;iq type="result" from="stpeter@jabber.org/Gabber"&gt;
&lt;query xmlns="jabber:iq:version"&gt;
&lt;name&gt;Gabber&lt;/name&gt;
&lt;version&gt;0.8.1 (Powered by: jabberoo 1.0.0&lt;/version&gt;
&lt;os&gt;Linux 2.2.16-22 i686&lt;/os&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre>

<h3>6.16. jabber:x:autoupdate——应用程序版本通知</h3>

<p>版本更改申请名字空间使服务器可以在一个应用的新版本可用时通知客户端。
例子：</p>

<pre><code>&lt;message from="winjab.sourceforge.net"&gt;
&lt;x xmlns="jabber:x:autoupdate"&gt;A new version of WinJab
is available, see http://winjab.sourceforge.net/
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.17. jabber:x:conference——会议邀请</h3>

<p>会议邀请名字空间使用户可以邀请其它 Jabber 用户到指定会议室。相关联信息——该会议室的 Jabber ID，内嵌在一个消息的<code>&lt;x/&gt;</code>元素中。</p>

<p>例子：</p>

<pre><code>&lt;message to="romeo@montague.net" from="juliet@capulet.com"&gt;
&lt;body&gt;Wherefore art thou Romeo?&lt;/body&gt;
&lt;x xmlns="jabber:x:conference" jid="balcony@conference.capulet.com/&gt;
&lt;/message&gt;
</code></pre>

<h3>6.18. jabber:x:delay——标记对象延时</h3>

<p>标记对象延时名字空间是消息和当前状态信息的时间戳信息，其中，当一个 Jabber 实体不在线时，当前状态信息可以保存并在稍后发送。当实体上线时，包含的信息标记对象延时名字空间使 Jabber 客户端显示出该包体最早产生的时间，而不是它发送给 Jabber 实体的时间。</p>

<p>例子：</p>

<pre><code>&lt;message
type=’groupchat’
from=’cauldron@conference.witches.org’&gt;
&lt;body&gt;Thrice the brinded cat hath mew’d.&lt;/body&gt;
&lt;x xmlns=’jabber:x:delay’
stamp=’10541031T21:43:40’&gt;Cached In GC History&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.19. jabber:x:encrypted——加密消息</h3>

<p>加密消息名字空间用来支持使用公共密钥（一般通过客户端使用 PGP 或 GPG，服务端用同样的名字空间进行加密来实现）加密的消息交互。一个相关的名字空间，<code>jabber:x:signed</code>，用来进行当前状态信息的加密。</p>

<p>例子：</p>

<pre><code>&lt;message from=’juliet@capulet.com/balcony’ to=’romeo@montague.net/orchard’&gt;
&lt;body&gt;This Message is Encrypted&lt;/body&gt;
&lt;x xmlns=’jabber:x:encrypted’&gt;
hQEOA7ucqu53AhlPEAP/ZbU6oPnRAbIcUxMK1XRVnkgZ/Agtq1tcTQuEZxbpZLl4
C/4psQGLgBU5h5Y3/khxtJTPXKn1izyc+DRZ8hqn2p4mwC8ioKTBJ6P6dfEpQEyt
a4bimM5fqdeh4gRkMhwThRSJxBCJBVVWFEViu+0KlHHB5AeeL4qwRGb2dhGjIgQD
/R9x0D0qtgBGwf/TVnRGZYRX7epxCNuNDEYKZSs4LEoTPL8CVsAWOzS2QgS0GBqt
tFDKId6XaNu36dB2D8VHdxQnI8RtHo9pfTYDaXWB3dMGTt896iEO/sTuucYObf3s
K5Kygg0uWpBpvQPj8Y041FhnUBz8DRGCnuFLQxCI6ch4ybauXfOKNOGDQwmsnJZm
6OaeVFUwdsedI3c6VdQtodnWVutckR5BOjnn0VqnhrVTu7cp6VXrrRK4g9atPEe6
C4R/MilBjzIJBcET0jhWuAyiBo3gN/6IqYRZNSXL9ZqGPJwNTlYim1EHN3qBqiUw
zUMamEoRzcusn80Z7kylve5ujIeSD/pVwoawHHvLp92kO2hd0yGD0UrWSfKU1o6y
EY8yhZ5P1v02pIKigAUI2c6LTDxt/KhSxQ==
=fijN
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.20. jabber:x:envelope——消息信封</h3>

<pre><code>消息信封名字空间是表明消息有更多的寻址方式，如联合email进行的寻址。下面是一些所支持的名字空间：
</code></pre>

<ul>
<li>to</li>
<li>cc</li>
<li>replyto</li>
<li>from</li>
<li>forwardedby</li>
</ul>


<p>上述每一个元素都带有一个<code>jid</code>属性来标识 Jabber 实体是发送、中转、还是收到消息。
例子：</p>

<pre><code>&lt;message from=’juliet@capulet.com/tomb’ to=’romeo@montague.net/tomb’&gt;
&lt;body&gt;And there I am. Where is my Romeo?&lt;/body&gt;
&lt;x xmlns=’jabber:x:envelope’&gt;
&lt;to jid=’romeo@heaven.org&gt;Romeo&lt;/to&gt;
&lt;forwardedby jid=’root@heaven.org&gt;God&lt;/forwardedby&gt;
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.21. jabber:x:event——消息事件</h3>

<pre><code>消息时间名字空间是标识一条消息的状态的一个机制。现在，事件与一条消息如下般相关联：
</code></pre>

<ul>
<li><composing/>——个用户正在对消息进行回复</li>
<li><delivered/>——发送给指定接收者的消息</li>
<li><displayed/>——显示给指定接收者的消息</li>
<li><offline/>——为离线进行存储的消息</li>
</ul>


<p>对于客户端来说，这些消息事件的支持是可选的，而且，只有在另一用户在聊天中发出请求，这些消息事件才会被发送。不同的 Jabber 客户端将对当前状态消息事件进行不同的显示。</p>

<p>对消息通知的请求的例子：</p>

<pre><code>&lt;message
from="juliet@capulet.com/balcony"
to="romeo@montague.net/orchard"
id="1001"&gt;
&lt;body&gt;By whose direction found’st thou out this place?&lt;/body&gt;
&lt;x xmlns="jabber:x:event"&gt;
&lt;composing/&gt;
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<p>发送消息通知的例子：</p>

<pre><code>&lt;message from="romeo@montague.net/orchard" to="juliet@capulet.com/balcony"&gt;
&lt;body&gt;By whose direction found’st thou out this place?&lt;/body&gt;
&lt;x xmlns="jabber:x:event"&gt;
&lt;composing/&gt;
&lt;id&gt;1001&lt;id/&gt;
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<p>可以同时请求多个消息事件。</p>

<h3>6.22. jabber:x:expire——消息到期</h3>

<p>消息到期名字空间是说明一条消息拥有一个有限的存活事件的一个简单扩展。如果消息被离线存储，而到了到期时间，服务器将不再发送该消息。如果一条消息为预览就进行发送，Jabber 客户端可以选择不显示该消息。<code>secondes</code>属性定义消息发送的事件。</p>

<p>例子：</p>

<pre><code>&lt;message from="sailor@denmark.com" to="horatio@denmark.com"&gt;
&lt;body&gt;There’s a letter for you sir&lt;/body&gt;
&lt;x xmlns="jabber:x:expire" seconds="3600"/&gt;
&lt;/message&gt;
</code></pre>

<h3>6.23. jabber:x:oob——绑定数据输出</h3>

<p>绑定数据输出名字空间使用户可以通过交换一个标准的 URL 来实现文件传输的目电。使用<code>jabber:x:oob</code>的 <code>URLs</code> 交换可以包含任一消息（在一个<code>&lt;x/&gt;</code>子元素内），感觉就像 email 里的附件一样。多个附件可以包含在同一个消息中。</p>

<p>例子：</p>

<pre><code>&lt;message from="sailor@denmark.com" to="horatio@denmark.com"&gt;
&lt;body&gt;URL Attached.&lt;/body&gt;
&lt;x xmlns="jabber:x:oob"&gt;
&lt;url&gt;http://denmark.com/act4/letter-1.html&lt;/url&gt;
&lt;desc&gt;There’s a letter for you sir&lt;/desc&gt;
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.24. jabber:x:roster——内置的花名册条目</h3>

<p>内置的花名册条目使用户可以在一个消息中包含花名册条目，这样很容易在用户之间发送联系方式。每一个花名册条目都包含在一个<code>&lt;x/&gt;</code>的一个<code>&lt;item/&gt;</code>子元素中。这个<code>&lt;x/&gt;</code>元素一般用在一个<code>&lt;message/&gt;</code>元素中，但这不是必须的。</p>

<p>例子：</p>

<pre><code>&lt;message to="hamlet@denmark.com"&gt;
&lt;body&gt;
Here are some new Jabber users
to add to your contact list!
&lt;/body&gt;
&lt;x xmlns="jabber:x:roster"&gt;
&lt;item jid="claudius@denmark.com" name="King"&gt;
&lt;group&gt;Royalty&lt;/group&gt;
&lt;/item&gt;
&lt;item jid="horatio@denmark.com" name="Horatio"&gt;
&lt;group&gt;Friends&lt;/group&gt;
&lt;/item&gt;
&lt;item jid="fortinbras@norway" name="Prince Fortinbras"/&gt;
&lt;/x&gt;
&lt;/message&gt;
</code></pre>

<h3>6.25. jabber:x:signed——有符号的当前状态</h3>

<p>有符号的当前状态名字空间用来支持交换使用公共密钥（客户端使用 PGP 或 GPG，服务端使用同样的名字空间进行加密）加密的当前状态信息。一个相关的名字空间，<code>jabber:x:encrypted</code>用来支持加密消息。</p>

<p>例子：</p>

<pre><code>&lt;presence from=’juliet@capulet.com/balcony’ to=’romeo@montague.net/orchard’&gt;
&lt;show&gt;away&lt;/show&gt;
&lt;status&gt;be back later&lt;/status&gt;
&lt;x xmlns=’jabber:x:signed’&gt;
iD8DBQA6kasv0xpc2/POfPkRAnz0AJ9UEYYWWSReddIKk3AYMfTFtqQDJwCfbcLd
JcSUOR0FlS+rDFjAPaSMgSM+iNaNm
&lt;/x&gt;
&lt;/presence&gt;
</code></pre>

<h3>6.26. vcard-temp——临时vCard</h3>

<p>vCard 格式是一个“电子商务卡的标准格式，通过使用通过互联网进行个人数据的直接交换，如同在非互联网下的环境一样”。由于 XML 的 vCard 的格式还没有标准化，Jabber.org 项目在 XML 的 vCard 标准建立之前，暂时设置了这样一个临时名字文件。由于这几年在 vCar d的 XML 的官方标准的指定上没有任何进步，Jabber.org 开发者专门为这个项目创建了一个项目吸引 Jabber 社区外其它开发者的注意。因此，最后的 XML 的 vCard 格式的最后 DTD 可能会在下面的 URL 中找到：</p>

<p><a href="http://www.vcard-xml.org/">http://www.vcard-xml.org/</a></p>

<p>例子1（对 vCard 的客户端请求）：</p>

<pre><code>&lt;iq type="get"&gt;
&lt;vCard xmlns="vcard-temp"/&gt;
&lt;/iq&gt;
</code></pre>

<p>例子2（客户端收到 vCard 数据）：</p>

<pre><code>&lt;iq type="result"&gt;
&lt;vCard version="3.0" xmlns="vcard-temp"&gt;
vCard data goes here
&lt;/vCard&gt;
&lt;/iq&gt;
</code></pre>

<p>例子3（客户端向服务端发送 vCard）：</p>

<pre><code>&lt;iq type="set"&gt;
&lt;vCard version="3.0"&gt;
vCard data goes here
&lt;/vCard&gt;
&lt;/iq&gt;
</code></pre>

<h2>7. 使用用例</h2>

<p>这一部分提供一些在 Jabber 协议上略有不同的观点，通过用例来阐述。下面每一个例子都展示一个 Jabber 用户完成一个完整的任务的消息流程，该流程包括接收和发送，如注册到一台服务器，登陆，改变当前状态，或者发送一条消息。如果时间允许，我将把这部分引申的更远。</p>

<h3>7.1. Jabber用户注册</h3>

<p>本用例同时显示 Jabber 用户向服务器开启一个 socket 的连接，以及服务器的响应(如：&lt;stream:stream>标签)。</p>

<h3>1. Jabber用户通过开启一个从客户端到服务器端的XML流，来申请一个在服务器上的socket连接。</h3>

<pre><code>SEND: &lt;stream:stream
to=’capulet.com’
xmlns=’jabber:client’
xmlns:stream=’http://etherx.jabber.org/streams’&gt;
</code></pre>

<h3>2.服务器通过开启一个从服务器到客户端的XML流进行回复。</h3>

<pre><code>RECV: &lt;stream:stream
from=’capulet.com’
id=’180763465’
xmlns=’jabber:client’
xmlns:stream=’http://etherx.jabber.org/streams’&gt;
</code></pre>

<h3>3.Jabber用户提供一个需要注册一个帐号（理论上，这需要一个不同的顺序：首先询问服务器需要什么信息，然后服务器器告知客户端需要什么样的信息；但在实际中，假定需要的信息是：用户名，资源，密码）的信息。</h3>

<pre><code>SEND:   &lt;iq id=’1’ type=’set’&gt;
           &lt;query xmlns=’jabber:iq:register’&gt;
               &lt;username&gt;Juliet&lt;/username&gt;
               &lt;resource&gt;balcony&lt;/resource&gt;
           &lt;/query&gt;
        &lt;/iq&gt;
</code></pre>

<h3>4.服务器响应一个空的类型为”result”的iq元素，表示注册已成功。</h3>

<pre><code>RECV:   &lt;iq id=’1’ type=’result’/&gt;
</code></pre>

<h3>7.2. Jabber用戶登陆</h3>

<h4>1.Jabber用户询问服务器，登陆所需要提供的信息。</h4>

<pre><code>SEND:  &lt;iq id=’2’ type=’get’&gt;
           &lt;query xmlns=’jabber:iq:auth’&gt;
              &lt;username&gt;Juliet&lt;/username&gt;
           &lt;/query&gt;
       &lt;/iq&gt;
</code></pre>

<h4>2.服务器提示Jabber用户登陆所需要的信息。</h4>

<pre><code>RECV:  &lt;iq id=’2’ type=’result’&gt;
           &lt;query xmlns=’jabber:iq:auth’&gt;
              &lt;username&gt;Juliet&lt;/username&gt;
              &lt;password/&gt;
              &lt;digest/&gt;
              &lt;sequence&gt;500&lt;sequence/&gt;
              &lt;token&gt;3B905BFD&lt;/token&gt;
              &lt;resource/&gt;
           &lt;/query&gt;
       &lt;/iq&gt;
</code></pre>

<h4>3. Jabber用户提供所需的信息——在本例中，是一个<hash/>元素，它是对信息进行一个零度知识认证的一个哈希。（详情请见<a href="http://docs.jabber.org/draft-proto/html/zerok.html%EF%BC%89%E3%80%82">http://docs.jabber.org/draft-proto/html/zerok.html%EF%BC%89%E3%80%82</a></h4>

<pre><code>SEND:  &lt;iq id=’3’ type=’set’&gt;
           &lt;query xmlns=’jabber:iq:auth’&gt;
              &lt;username&gt;Juliet&lt;/username&gt;
              &lt;resource&gt;balcony&lt;/resource&gt;
                          &lt;hash&gt;77d7eacde5e56b9622d0a075cb88361b110f
b9d7&lt;/hash&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h4>4. 服务器响应一个空的类型为”result”的iq元素，表明登陆成功。</h4>

<pre><code>RECV:  &lt;iq id=’3’ type=’result’/&gt;
</code></pre>

<h4>5. Jabber 用户发送当前状态给服务器，表明其在线。</h4>

<pre><code>SEND:  &lt;presence&gt;
           &lt;status&gt;Online&lt;/status&gt;
       &lt;/presence&gt;
</code></pre>

<h3>7.3. Jabber用户增加一个联系人</h3>

<h4>1.Jabber 客户端在花名册上增加一个联系人（只是预备的操作）。</h4>

<pre><code>SEND:  &lt;iq type=’set’&gt;
           &lt;query xmlns=’jabber:iq:roster’&gt;
              &lt;item jid=’romeo@montague.net’
Name=’remeo’/&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h4>2.Jabber用户发送一个对该联系人的订阅请求。</h4>

<pre><code>SEND:  &lt;presence to’remeo@montague.net’ type=’subscribe’&gt;
           &lt;status&gt;Wherefore are thou?&lt;/status&gt;
       &lt;/presence&gt;
</code></pre>

<h4>3.服务器发送一个花名单推送给用户一个新条目和一个类型为”none”的订阅（早已有了该订阅）。</h4>

<pre><code>RECV:  &lt;iq type=’set’&gt;
           &lt;query xmlns=’jabber:iq:roster’&gt;
              &lt;item jid=’romeo@montague.net’
name=’romeo’
subscription=’none’/&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h4>4.服务器发送一个类型为”result”的iq包，表示花名册推送成功（让人有点疑惑的是，这个包是从Jabber用户发送到Jabber用户的！）</h4>

<pre><code>RECV:  &lt;iq
from=’juliet@capulet.com/balcony’
to=’julie@capulet.com/balcony’
type=’result’&gt;
</code></pre>

<h4>5.服务器发送另一个花名单推送，这次是ask=’subscribe’属性，表示订阅的状态未定。</h4>

<pre><code>RECV:  &lt;iq type=’set’&gt;
           &lt;query xmlns=’jabber:iq:roster’&gt;
              &lt;item
ask=’subscribe’
jid=’romeo@montague.net’
name=’romeo’
subscription=’none’/&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h4>6.Romeo对订阅请求的下一个响应会是什么呢？现在我们假定订阅以Romeo接受订阅请求为“结束”的。</h4>

<pre><code>RECV:  &lt;presence
from=’romeo@montague.net’
to=’juliet@capulet.com’
type=’subscribed’/&gt;
</code></pre>

<h4>7.服务器再次发送一个花名单推送给客户端，这次subscription=’to’，表示订阅请求被接受了（Juliet现在可以订阅到Romeo的当前状态了）。</h4>

<pre><code>RECV:  &lt;iq type=’set’&gt;
           &lt;query xmlns=’jabber:iq:roster’&gt;
              &lt;item
jid=’romeo@montague.net’
name=’romeo’
subscription=’to’/&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h3>7.4. Jabber用户获得花名册</h3>

<pre><code>           SEND:  &lt;iq type=’get’&gt;
                     &lt;query xmlns=’jabber:iq:roster’/&gt;
                  &lt;/iq&gt;

RECV:&lt;iq from=’juliet@capulet.com/balcony’ type=’result’&gt;    
                     &lt;query xmlns=’jabber:iq:roster’&gt;
                         &lt;item
jid=’romeo@montague.net’
name=’romeo’
subscription=’both’/&gt;
                     &lt;/query&gt;
                  &lt;/iq&gt;
</code></pre>

<h3>7.5. Jabber用户发送一条消息</h3>

<pre><code>SEND:  &lt;message to’romeo@montague.net’&gt;
          &lt;body&gt;Wherefore are thou?&lt;/body&gt;
       &lt;/message&gt;
</code></pre>

<p>注意：服务器会根据 Jabber 用户的会话信息加上一个源地址，这样接收者收到消息时，消息中已经包含了源地址。</p>

<h3>7.6. Jabber用户改变当前状态</h3>

<pre><code>SEND:  &lt;presence&gt;
           &lt;status&gt;stepped away…&lt;/status&gt;
           &lt;show&gt;away&lt;/show&gt;
       &lt;/presence&gt;
</code></pre>

<h3>7.7. Jabber用户登出</h3>

<p>登出时很容易的，只需要关闭 <code>&lt;stream&gt;……</code></p>

<pre><code>   SEND:  &lt;/stream:stream&gt;
   RECV:  &lt;/stream:stream&gt;
</code></pre>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">陈斌彬</span></span>

      




<time class='entry-date' datetime='2015-06-30T11:16:06+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:16 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>ios</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/30/bash-xun-huan-yu-fen-zhi/" title="Previous Post: Bash - 循环与分支">&laquo; Bash - 循环与分支</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/30/mac-vmware-gong-xiang-wen-jian-jia-she-zhi/" title="Next Post: Mac Vmware 共享文件夹设置(原创)">Mac Vmware 共享文件夹设置(原创) &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section> 
  <h1>文章分类</h1> 
  <ul id="categories"> 
    <li class='category'><a href='/blog/categories/android/'>android (126)</a></li>
<li class='category'><a href='/blog/categories/computer/'>computer (158)</a></li>
<li class='category'><a href='/blog/categories/csharp/'>csharp (56)</a></li>
<li class='category'><a href='/blog/categories/energy/'>energy (17)</a></li>
<li class='category'><a href='/blog/categories/git/'>git (15)</a></li>
<li class='category'><a href='/blog/categories/github/'>github (2)</a></li>
<li class='category'><a href='/blog/categories/ionic/'>ionic (22)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (740)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (23)</a></li>
<li class='category'><a href='/blog/categories/js/'>js (143)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (126)</a></li>
<li class='category'><a href='/blog/categories/linux/'>linux (63)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (71)</a></li>
<li class='category'><a href='/blog/categories/net/'>net (417)</a></li>
<li class='category'><a href='/blog/categories/network/'>network (2)</a></li>
<li class='category'><a href='/blog/categories/objective-c/'>objective-c (78)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (4)</a></li>
<li class='category'><a href='/blog/categories/php/'>php (24)</a></li>
<li class='category'><a href='/blog/categories/python/'>python (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (5)</a></li>
<li class='category'><a href='/blog/categories/ruby/'>ruby (23)</a></li>
<li class='category'><a href='/blog/categories/sql/'>sql (8)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (40)</a></li>
<li class='category'><a href='/blog/categories/video/'>video (1)</a></li>
<li class='category'><a href='/blog/categories/web/'>web (185)</a></li>
  
    </ul> 
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/08/23/webviewchu-shi-hua/">Webview初始化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/22/tong-ji-zheng-ge-xcodegong-cheng-dai-ma-xing-shu/">统计整个Xcode工程代码行数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/22/ionic-zi-ding-yi-serviceswen-jian/">Ionic 自定义services文件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/19/ioskai-fa-xiao-ji-dai-shu-ru-kuang-(textfield)de-uialertview/">iOS开发小记：带输入框（TextField）的UIAlertView</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/19/uilabelzhi-ding-wei-zhi-gai-bian-zi-ti-yan-se/">Uilabel指定位置改变字体颜色</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 陈斌彬 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
