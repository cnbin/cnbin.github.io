<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[陈斌彬的技术博客]]></title>
  <link href="http://cnbin.github.io/atom.xml" rel="self"/>
  <link href="http://cnbin.github.io/"/>
  <updated>2016-08-08T19:02:39+08:00</updated>
  <id>http://cnbin.github.io/</id>
  <author>
    <name><![CDATA[陈斌彬]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJS使用Controller实现URL跳转]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/angularjsshi-yong-controllershi-xian-urltiao-zhuan/"/>
    <updated>2016-08-08T17:04:06+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/angularjsshi-yong-controllershi-xian-urltiao-zhuan</id>
    <content type="html"><![CDATA[<!--More-->


<p>1.js定义一个controller</p>

<pre><code>function MyCtrl($scope, $location) {

    $scope.jumpToUrl = function(path) {

        //TODO:add code here

    };

}
</code></pre>

<p>2.html里面应用controller</p>

<pre><code>&lt;div ng-controller=‘MyCtrl’&gt;

    &lt;button ng-click="jumpToUrl('/signin')"&gt;signin&lt;/button&gt;

&lt;/div&gt;
</code></pre>

<p>3.controller里面TODO的位置填入</p>

<pre><code>$location.path(path);
</code></pre>

<p>然后运行起来就可以看效果了。</p>

<p>假设当前页面的url是<code>http://127.0.0.1:8080/#/home</code></p>

<pre><code>$location.path(path);执行后就会跳到http://127.0.0.1:8080/#/signin
</code></pre>

<p>如果你发现页面不能正常跳转，可以在$location.path(path);后面再加上一句</p>

<pre><code>var curUrl = $location.absUrl(); //用来显示url全路径
</code></pre>

<p>调试跟踪页面时查看curUrl的值到底变成多少，大概就能猜出问题出在哪了。</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/rockwill/article/details/25196127">http://blog.csdn.net/rockwill/article/details/25196127</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下ionic调试]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi/"/>
    <updated>2016-08-08T15:36:54+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/macxia-ionicdiao-shi</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://my.oschina.net/twinkling/blog/504824?p=">http://my.oschina.net/twinkling/blog/504824?p=</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebview 的缓存策略和验证，以及 Web 相关]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/uiwebview-de-huan-cun-ce-lue-he-yan-zheng-,yi-ji-web-xiang-guan/"/>
    <updated>2016-08-08T08:25:11+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/uiwebview-de-huan-cun-ce-lue-he-yan-zheng-,yi-ji-web-xiang-guan</id>
    <content type="html"><![CDATA[<!--More-->


<p>缓存策略 NSURLRequestCachePolicy</p>

<p>NSURLRequestUseProtocolCachePolicy
缓存策略定义在 web 协议实现中，用于请求特定的URL。是默认的URL缓存策略
Specifies that the caching logic defined in the protocol implementation, if any, is used for a particular URL load request. This is the default policy for URL load requests.</p>

<p>NSURLRequestReloadIgnoringLocalCacheData
从服务端获取数据，忽略本地缓存</p>

<p>Specifies that the data for the URL load should be loaded from the originating source. No existing cache data should be used to satisfy a URL load request.</p>

<p>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</p>

<p>不仅忽略本地的缓存数据，还忽略中间网络媒介（如代理服务器）忽略缓存。直接从最原始的服务器拿取
Specifies that not only should the local cache data be ignored, but that proxies and other intermediates should be instructed to disregard their caches so far as the protocol allows.</p>

<p>NSURLRequestReloadIgnoringCacheData
被NSURLRequestReloadIgnoringLocalCacheData替换了</p>

<p>Replaced by NSURLRequestReloadIgnoringLocalCacheData.</p>

<p>NSURLRequestReturnCacheDataElseLoad</p>

<p>已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，从数据源读取
Specifies that the existing cached data should be used to satisfy the request, regardless of its age or expiration date. If there is no existing data in the cache corresponding the request, the data is loaded from the originating source.</p>

<p>NSURLRequestReturnCacheDataDontLoad</p>

<p>已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，不要去数据源读取，该请求被设置为失败，这种情况多用于离线模式</p>

<p>Specifies that the existing cache data should be used to satisfy a request, regardless of its age or expiration date. If there is no existing data in the cache corresponding to a URL load request, no attempt is made to load the data from the originating source, and the load is considered to have failed. This constant specifies a behavior that is similar to an “offline” mode.</p>

<p>NSURLRequestReloadRevalidatingCacheData</p>

<p>已经存在的缓存数据先去数据源验证有效性，如果无效，将从数据源获取
Specifies that the existing cache data may be used provided the origin source confirms its validity, otherwise the URL is loaded from the origin source.</p>

<p>NSURLRequestUseProtocolCachePolicy 和 NSURLRequestReloadRevalidatingCacheData 区别</p>

<p>个人意见，仅供参考，如有错误，请指出来，这对我很重要，谢谢</p>

<p>NSURLRequestReloadRevalidatingCacheData 是一定要和原始的数据源验证 cache 是否有效。
而NSURLRequestUseProtocolCachePolicy 是根据 web 的协议来控制缓存，服务端返回数据的 head 有相关的信息。它可能会返回中间网络媒介（如代理服务器中的数据）</p>

<p>针对缓存策略做一下本地测试，这是非常有必要的</p>

<pre><code>NSURL *webUrl = [NSURL URLWithString:@"http://localhost/test.txt"];       
NSURLRequest *request =[NSURLRequest requestWithURL:webUrl cachePolicy:NSURLRequestReloadRevalidatingCacheData timeoutInterval:60];       
[self.mainWebView loadRequest:request];  
</code></pre>

<p>这里使用NSURLRequestReloadRevalidatingCacheData， 返回cache数据一定要先验证数据有效。</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/mangosnow/article/details/37831529">http://blog.csdn.net/mangosnow/article/details/37831529</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graceful-fs Warning When Running Grunt Task]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/08/graceful-fs-warning-when-running-grunt-task/"/>
    <updated>2016-08-08T07:06:43+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/08/graceful-fs-warning-when-running-grunt-task</id>
    <content type="html"><![CDATA[<!--More-->


<p>Warning: (node:2771) fs: re-evaluating native module sources is not supported. If you are using the graceful-fs module, please update it to a more recent version.</p>

<p>If you&rsquo;re using homebrew here is how you can downgrade to v5.11.0</p>

<pre><code>brew tap homebrew/versions
brew unlink node
brew install homebrew/versions/node5
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FKConsole - Xcode控制台中文显示调整插件]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/04/fkconsole-xcodekong-zhi-tai-zhong-wen-xian-shi-diao-zheng-cha-jian/"/>
    <updated>2016-08-04T08:13:32+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/04/fkconsole-xcodekong-zhi-tai-zhong-wen-xian-shi-diao-zheng-cha-jian</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://www.tuicool.com/articles/yUjaYv">http://www.tuicool.com/articles/yUjaYv</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac查看Http请求分析-httpie]]></title>
    <link href="http://cnbin.github.io/blog/2016/08/04/httpie/"/>
    <updated>2016-08-04T08:05:55+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/08/04/httpie</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="https://github.com/cnbin/httpie">https://github.com/cnbin/httpie</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods升级后（最新版本1.0.1），安装第三方库的时候会报如下错误]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/27/cocoapodssheng-ji-hou-(zui-xin-ban-ben-1-dot-0-1),an-zhuang-di-san-fang-ku-de-shi-hou-hui-bao-ru-xia-cuo-wu/"/>
    <updated>2016-07-27T17:39:05+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/27/cocoapodssheng-ji-hou-(zui-xin-ban-ben-1-dot-0-1),an-zhuang-di-san-fang-ku-de-shi-hou-hui-bao-ru-xia-cuo-wu</id>
    <content type="html"><![CDATA[<!--More-->


<p>CocoaPods升级后（最新版本1.0.1），安装第三方库的时候会报如下错误：</p>

<p>　　The dependency <code>AFNetworking (~&gt; 3.1.0)</code> is not used in any concrete target.</p>

<p>原因：CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。</p>

<p>解决步骤：</p>

<p>1）检查CocoaPods的版本</p>

<pre><code>        pod --version
</code></pre>

<p>2) 升级或安装最新版本（目前版本1.0.1）</p>

<p>注意：如果cocoapods已经是1.0.1版本，则跳过该步骤直接进入第三个步骤。</p>

<pre><code>升级命令：sudo gem update -n /usr/local/bin --system



安装命令：sudo gem install -n /usr/local/bin cocoapods
</code></pre>

<p>(3)修改Podfile的内容</p>

<p>修改前的Podfile文件的内容：</p>

<pre><code>platform:ios,'7.0'
pod 'MJRefresh', '~&gt; 3.1.0'
pod 'SDWebImage', '~&gt; 3.7.6'
pod 'SVProgressHUD', '~&gt; 2.0.3'
pod 'AFNetworking', '~&gt; 3.1.0'
</code></pre>

<p>修改后的Podfile文件的内容：</p>

<pre><code>platform:ios,'7.0'
target "MyProject" do
pod 'MJRefresh', '~&gt; 3.1.0'
pod 'SDWebImage', '~&gt; 3.7.6'
pod 'SVProgressHUD', '~&gt; 2.0.3'
pod 'AFNetworking', '~&gt; 3.1.0'
end
</code></pre>

<p>　　在Podfile文件中需要明确指出使用第三方库的target,这里target后面跟的就是自己项目本身的Target;也就是项目中的tagrets中的那个项目名称。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Too Many Arguments Provided to Function-like Macro Invocation]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/27/too-many-arguments-provided-to-function-like-macro-invocation/"/>
    <updated>2016-07-27T16:55:40+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/27/too-many-arguments-provided-to-function-like-macro-invocation</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://www.jianshu.com/p/8e55f6de1150">http://www.jianshu.com/p/8e55f6de1150</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoapods降低版本及卸载]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/27/cocoapodsjiang-di-ban-ben-ji-xie-zai/"/>
    <updated>2016-07-27T16:54:54+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/27/cocoapodsjiang-di-ban-ben-ji-xie-zai</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://www.meetrue.com/archives/133">http://www.meetrue.com/archives/133</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[导入FaceBook POP报错]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/27/dao-ru-facebook-popbao-cuo/"/>
    <updated>2016-07-27T16:53:37+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/27/dao-ru-facebook-popbao-cuo</id>
    <content type="html"><![CDATA[<!--More-->


<p>使用cocoaPods下载下来POP动画库，想手动导入到原来的工程，但是到了一堆错，什么文件没找到之类的。最后索性修改了所有的报错头文件：
修改POP.h后 :</p>

<pre><code>#import "POPAnimatableProperty.h"
#import "POPAnimation.h"
#import "POPAnimationEvent.h"
#import "POPAnimationExtras.h"
#import "POPAnimationTracer.h"
#import "POPAnimator.h"
#import "POPBasicAnimation.h"
#import "POPCustomAnimation.h"
#import "POPDecayAnimation.h"
#import "POPDefines.h"
#import "POPGeometry.h"
#import "POPLayerExtras.h"
#import "POPPropertyAnimation.h"
#import "POPSpringAnimation.h"
</code></pre>

<p>在其他的文件里边将<code>&lt;pop/xxx.h&gt;</code> 全部修改成xxx.h.
我使用的方法比较笨，只能解决燃眉之急，如果有更好的方法，希望能共享下。
顶</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CocoaPods遇到的几个坑]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/26/shi-yong-cocoapodsyu-dao-de-ji-ge-keng/"/>
    <updated>2016-07-26T17:19:45+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/26/shi-yong-cocoapodsyu-dao-de-ji-ge-keng</id>
    <content type="html"><![CDATA[<!--More-->


<p>首先是CocoaPods报错：The dependency `` is not used in any concrete target</p>

<p>错误内容</p>

<pre><code>/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwin14/rbconfig.rb:213: warning: Insecure world writable dir /Applications/Cocos/tools/ant/bin in PATH, mode 040777 Re-creating CocoaPods due to major version update. Updating local specs repositories Analyzing dependencies

[!] The dependency `ReactiveCocoa (= 2.1.8)` is not used in any concrete target.

The dependency `objectiveflickr (= 2.0.4)` is not used in any concrete target.

The dependency `LinqToObjectiveC (= 2.0.0)` is not used in any concrete target.

The dependency `SDWebImage (= 3.6)` is not used in any concrete target.
</code></pre>

<p>查了查好像是配置podfile文件的问题</p>

<p>作如下修改</p>

<pre><code>platform :ios, ‘7.0‘

target "RWTFlickrSearch" do
pod ‘ReactiveCocoa‘, ‘2.1.8‘
pod ‘objectiveflickr‘, ‘2.0.4‘
pod ‘LinqToObjectiveC‘, ‘2.0.0‘
pod ‘SDWebImage‘, ‘3.6‘
end
</code></pre>

<p>这样再运行pod install，就会成功了。</p>

<p>原因是podfile升级到最新版本，pod里的内容必须明确指出所用第三方库的target</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把 Mac 上的 Bash 换成 Zsh]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/26/ba-mac-shang-de-bash-huan-cheng-zsh/"/>
    <updated>2016-07-26T07:57:57+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/26/ba-mac-shang-de-bash-huan-cheng-zsh</id>
    <content type="html"><![CDATA[<!--More-->


<p>下载一个 .oh-my-zsh 配置（推荐有）</p>

<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
</code></pre>

<p>创建新配置</p>

<p>NOTE: 如果你已经有一个 .zshrc 文件，那么备份一下吧</p>

<pre><code>cp ~/.zshrc ~/.zshrc.orig
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre>

<p>把 zsh 设置成默认的 shell:</p>

<pre><code>chsh -s /bin/zsh
</code></pre>

<p>重启 zsh (打开一个新的 terminal 窗口)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OX10.11安装homebrew和cocoapods]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/26/ox10-dot-11an-zhuang-homebrewhe-cocoapods/"/>
    <updated>2016-07-26T07:27:40+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/26/ox10-dot-11an-zhuang-homebrewhe-cocoapods</id>
    <content type="html"><![CDATA[<!--More-->


<p>rvm pkg install libyaml</p>

<p><a href="http://serverfault.com/questions/442150/how-to-fix-ruby-installation-is-missing-psych-for-yaml-output-on-centos">http://serverfault.com/questions/442150/how-to-fix-ruby-installation-is-missing-psych-for-yaml-output-on-centos</a></p>

<p>下面这句话输入后
/usr/bin/ruby -e &ldquo;$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)&rdquo;</p>

<p>cmd+shift+g 打开/usr 文件夹后，点击local文件夹，右击简介，选择权限为可读写。
然后修改/usr/local文件夹下面Library和share文件夹的权限为可读写。</p>

<p>因为cocoapod需要ruby>=2.2，所以
brew update
rvm install 2.2</p>

<p>然后
sudo gem install cocoapods</p>

<p>gem sources -a <a href="https://ruby.taob.org/">https://ruby.taob.org/</a></p>

<p>获取ruby已安装列表
rvm list</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS关于微信支付]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/11/iosguan-yu-wei-xin-zhi-fu/"/>
    <updated>2016-07-11T17:38:42+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/11/iosguan-yu-wei-xin-zhi-fu</id>
    <content type="html"><![CDATA[<!--More-->


<h3><a href="http://blog.csdn.net/wwmusic/article/details/46727663">http://blog.csdn.net/wwmusic/article/details/46727663</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tools:context]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/09/tools-context/"/>
    <updated>2016-07-09T14:04:51+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/09/tools-context</id>
    <content type="html"><![CDATA[<!--More-->


<pre><code>&lt;TextView  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_centerHorizontal="true"  
        android:layout_centerVertical="true"  
        android:text="@string/hello_world"  
        tools:context=".MainActivity" /&gt;  
</code></pre>

<p>一直对于 tools:context=&ldquo;.MainActivity"这句不懂，今天查了下，发现是这样的：</p>

<p>tools:context=&ldquo;activity name"这一句不会被打包进APK。只是ADT的Layout Editor在你当前的Layout文件里面设置对应的渲染上下文，说明你当前的Layout所在的渲染上下文是activity name对应的那个activity，如果这个activity在manifest文件中设置了Theme，那么ADT的Layout Editor会根据这个Theme来渲染你当前的Layout。就是说如果你设置的MainActivity设置了一个Theme.Light（其他的也可以），那么你在可视化布局管理器里面看到的背景阿控件阿什么的就应该是Theme.Light的样子。仅用于给你看所见即所得的效果而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 获取当前年份 月份 日期]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/09/java-huo-qu-dang-qian-nian-fen-yue-fen-ri-qi/"/>
    <updated>2016-07-09T09:02:08+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/09/java-huo-qu-dang-qian-nian-fen-yue-fen-ri-qi</id>
    <content type="html"><![CDATA[<!--More-->


<pre><code>import Java.util.Calendar;

public class Main {
  public static void main(String[] args) {
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DATE);
    int month = cal.get(Calendar.MONTH) + 1;
    int year = cal.get(Calendar.YEAR);
    int dow = cal.get(Calendar.DAY_OF_WEEK);
    int dom = cal.get(Calendar.DAY_OF_MONTH);
    int doy = cal.get(Calendar.DAY_OF_YEAR);

    System.out.println("Current Date: " + cal.getTime());
    System.out.println("Day: " + day);
    System.out.println("Month: " + month);
    System.out.println("Year: " + year);
    System.out.println("Day of Week: " + dow);
    System.out.println("Day of Month: " + dom);
    System.out.println("Day of Year: " + doy);
  }
}

java.text.SimpleDateFormat formatter = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
java.util.Date currTime = new java.util.Date();

int year = currTime.getYear();//年

int month = currTime.getMonth()+1;//月

int week = currTime.getDay(); //星期几

int day = currTime.getDate();//日

String curTime = formatter.format(currTime);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对android中ActionBar中setDisplayHomeAsUpEnabled和setHomeButtonEnabled和setDisplayShowHomeEnabled方法的理解]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/08/dui-androidzhong-actionbarzhong-setdisplayhomeasupenabledhe-sethomebuttonenabledhe-setdisplayshowhomeenabledfang-fa-de-li-jie/"/>
    <updated>2016-07-08T15:29:07+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/08/dui-androidzhong-actionbarzhong-setdisplayhomeasupenabledhe-sethomebuttonenabledhe-setdisplayshowhomeenabledfang-fa-de-li-jie</id>
    <content type="html"><![CDATA[<!--More-->


<p>setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击。</p>

<p>actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP</p>

<p>actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME</p>

<p>actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM</p>

<p>actionBar.setDisplayShowTitleEnabled(true)   //对应ActionBar.DISPLAY_SHOW_TITLE。</p>

<p>其中setHomeButtonEnabled和setDisplayShowHomeEnabled共同起作用，如果setHomeButtonEnabled设成false，即使setDisplayShowHomeEnabled设成true，图标也不能点击</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中short类型变量]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/06/javazhong-shortlei-xing-bian-liang/"/>
    <updated>2016-07-06T09:01:25+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/06/javazhong-shortlei-xing-bian-liang</id>
    <content type="html"><![CDATA[<!--More-->


<p>首先来看一下Java中的基本类型，如下表：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/78f9859egw1f5jwt19ogkj20e10hf0uq.jpg" alt="img" /></p>

<p>java的基本类型存储长度都是固定的，不因机器的不同而不同，因此使java拥有了良好的移植性。</p>

<p>最近在做项目时，需要在一个变量里存放16位长的二进制数字，查看上表可知short类型正好符合需要。</p>

<p>但是因为java中的数字类型都是有符号的，因此short类型的第一位被用于表示符号，实际存储长度只有15位，</p>

<p>即－7FFF－＋7FFF。那如果要存放＋7FFF－＋FFFF的数字该怎么办呢？只有采取变通的办法，采用变换算法。我们可以利用－7FFF－－0001来存放大于7FFF的数字。转换公式为－(FFFF－X)－1。由于有了符号，所以＋0000和－0000是相等的，所以比无符号数少了1个数字，所以要在公式里减1，由于这个问题，用这个方法我们就不能存放＋8000了。</p>

<p>用这个方法可以基本满足我们的需要，如有特殊需要，如要存储＋8000，那只有采取别的办法了。</p>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/snakeqi/article/details/344069">http://blog.csdn.net/snakeqi/article/details/344069</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 如何解析Xml字符串]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/06/android-ru-he-jie-xi-xmlzi-fu-chuan/"/>
    <updated>2016-07-06T08:51:16+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/06/android-ru-he-jie-xi-xmlzi-fu-chuan</id>
    <content type="html"><![CDATA[<!--More-->


<p>在Android平台上可以使用Simple API for XML(SAX) 、 Document Object Model(DOM)和Android附带的pull解析器解析XML文件。</p>

<p>下面是本例子要解析的XML文件：itcast.xml</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persons&gt;
　　&lt;person id="23"&gt;
　　　　&lt;name&gt;李明&lt;/name&gt;
　　　　&lt;age&gt;30&lt;/age&gt;
　　&lt;/person&gt;
　　&lt;person id="20"&gt;
　　　　&lt;name&gt;李向梅&lt;/name&gt;
　　　　&lt;age&gt;25&lt;/age&gt;
　　&lt;/person&gt;
&lt;/persons&gt;
</code></pre>

<p>例子定义了一个javabean用于存放上面解析出来的xml内容， 这个javabean为Person，代码：</p>

<pre><code>public class Person {

    private Integer id;
    private String name;
    private Short age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
}

    public Short getAge() {
        return age;
    }

    public void setAge(Short age) {
        this.age = age;
    }
}
</code></pre>

<p>Pull解析器解析XML文件</p>

<p>Pull解析器的运行方式与 SAX 解析器相似。它提供了类似的事件，如：开始元素和结束元素事件，使用<code>parser.next()</code>可以进入下一个元素并触发相应事件。事件将作为数值代码被发送，因此可以使用一个switch对感兴趣的事件进行处理。当元素开始解析时，调用parser.nextText()方法可以获取下一个Text类型元素的值。</p>

<pre><code>//读取XML
public static List&lt;Person&gt; readXML(InputStream inStream) {

            XmlPullParser parser = Xml.newPullParser();

            try {
                        parser.setInput(inStream, "UTF-8");
                        int eventType = parser.getEventType();

                        Person currentPerson = null;
                        List&lt;Person&gt; persons = null;

                        while (eventType != XmlPullParser.END_DOCUMENT) {
                                    switch (eventType) {
                                    case XmlPullParser.START_DOCUMENT://文档开始事件,可以进行数据初始化处理
                                                persons = new ArrayList&lt;Person&gt;();
                                                break;

                                     case XmlPullParser.START_TAG://开始元素事件
                                                String name = parser.getName();
                                                if (name.equalsIgnoreCase("person")) {
                                                            currentPerson = new Person();
                                                            currentPerson.setId(new Integer(parser.getAttributeValue(null, "id")));
                                                } else if (currentPerson != null) {
                                                            if (name.equalsIgnoreCase("name")) {
                                                                        currentPerson.setName(parser.nextText());// 如果后面是Text元素,即返回它的值
                                                            } else if (name.equalsIgnoreCase("age")) {
                                                                        currentPerson.setAge(new Short(parser.nextText()));
                                                            }
                                                }
                                                break;

                                    case XmlPullParser.END_TAG://结束元素事件
                                                if (parser.getName().equalsIgnoreCase("person") &amp;&amp; currentPerson != null) {
                                                            persons.add(currentPerson);
                                                            currentPerson = null;
                                                }

                                                break;
                                    }

                                     eventType = parser.next();
                        }

            inStream.close();
            return persons;
            } catch (Exception e) {
                        e.printStackTrace();
            }

            return null;
}
</code></pre>

<h3>Resource Reference</h3>

<ul>
<li><a href="http://www.cnblogs.com/devinzhang/archive/2012/01/16/2323668.html">http://www.cnblogs.com/devinzhang/archive/2012/01/16/2323668.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS解析XML Demo]]></title>
    <link href="http://cnbin.github.io/blog/2016/07/05/iosjie-xi-xml-demo/"/>
    <updated>2016-07-05T15:26:02+08:00</updated>
    <id>http://cnbin.github.io/blog/2016/07/05/iosjie-xi-xml-demo</id>
    <content type="html"><![CDATA[<!--More-->


<p>webxml地址：<a href="http://ws.webxml.com.cn/WebServices/WeatherWS.asmx">http://ws.webxml.com.cn/WebServices/WeatherWS.asmx</a></p>

<p><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1f5j29y3ae8j208v0g8aan.jpg" alt="img" /></p>
]]></content>
  </entry>
  
</feed>
